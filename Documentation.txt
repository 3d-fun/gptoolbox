LIST OF FILES
  ./dithering/average.m
  ./dithering/comparison.m
  ./dithering/dither.m
  ./dithering/hatch.m
  ./dithering/randdither.m
  ./geometry/slerp.m
  ./imageprocessing/denoise.m
  ./imageprocessing/gray2rgb.m
  ./imageprocessing/imnorm.m
  ./imageprocessing/imshow_before_and_after.m
  ./imageprocessing/imshow_rgb.m
  ./imageprocessing/imtrim.m
  ./imageprocessing/ziprgb.m
  ./matlabPyrTools/binomialFilter.m
  ./matlabPyrTools/blur.m
  ./matlabPyrTools/blurDn.m
  ./matlabPyrTools/buildGpyr.m
  ./matlabPyrTools/buildLpyr.m
  ./matlabPyrTools/buildSCFpyr.m
  ./matlabPyrTools/buildSCFpyrLevs.m
  ./matlabPyrTools/buildSFpyr.m
  ./matlabPyrTools/buildSFpyrLevs.m
  ./matlabPyrTools/buildSpyr.m
  ./matlabPyrTools/buildSpyrLevs.m
  ./matlabPyrTools/buildWpyr.m
  ./matlabPyrTools/cconv2.m
  ./matlabPyrTools/clip.m
  ./matlabPyrTools/Contents.m
  ./matlabPyrTools/corrDn.m
  ./matlabPyrTools/entropy2.m
  ./matlabPyrTools/factorial.m
  ./matlabPyrTools/histo.m
  ./matlabPyrTools/histoMatch.m
  ./matlabPyrTools/imGradient.m
  ./matlabPyrTools/imStats.m
  ./matlabPyrTools/innerProd.m
  ./matlabPyrTools/kurt2.m
  ./matlabPyrTools/lplot.m
  ./matlabPyrTools/lpyrHt.m
  ./matlabPyrTools/maxPyrHt.m
  ./matlabPyrTools/mean2.m
  ./matlabPyrTools/mkAngle.m
  ./matlabPyrTools/mkAngularSine.m
  ./matlabPyrTools/mkDisc.m
  ./matlabPyrTools/mkFract.m
  ./matlabPyrTools/mkGaussian.m
  ./matlabPyrTools/mkImpulse.m
  ./matlabPyrTools/mkR.m
  ./matlabPyrTools/mkRamp.m
  ./matlabPyrTools/mkSine.m
  ./matlabPyrTools/mkSquare.m
  ./matlabPyrTools/mkZonePlate.m
  ./matlabPyrTools/modulateFlip.m
  ./matlabPyrTools/namedFilter.m
  ./matlabPyrTools/nextFig.m
  ./matlabPyrTools/pgmRead.m
  ./matlabPyrTools/pgmWrite.m
  ./matlabPyrTools/pixelAxes.m
  ./matlabPyrTools/pointOp.m
  ./matlabPyrTools/pwd2path.m
  ./matlabPyrTools/pyrBand.m
  ./matlabPyrTools/pyrBandIndices.m
  ./matlabPyrTools/pyrLow.m
  ./matlabPyrTools/range2.m
  ./matlabPyrTools/rconv2.m
  ./matlabPyrTools/rcosFn.m
  ./matlabPyrTools/reconLpyr.m
  ./matlabPyrTools/reconSCFpyr.m
  ./matlabPyrTools/reconSFpyr.m
  ./matlabPyrTools/reconSFpyrLevs.m
  ./matlabPyrTools/reconSpyr.m
  ./matlabPyrTools/reconSpyrLevs.m
  ./matlabPyrTools/reconWpyr.m
  ./matlabPyrTools/setPyrBand.m
  ./matlabPyrTools/shift.m
  ./matlabPyrTools/showIm.m
  ./matlabPyrTools/showLpyr.m
  ./matlabPyrTools/showSpyr.m
  ./matlabPyrTools/showWpyr.m
  ./matlabPyrTools/skew2.m
  ./matlabPyrTools/sp0Filters.m
  ./matlabPyrTools/sp1Filters.m
  ./matlabPyrTools/sp3Filters.m
  ./matlabPyrTools/sp5Filters.m
  ./matlabPyrTools/spyrBand.m
  ./matlabPyrTools/spyrHigh.m
  ./matlabPyrTools/spyrHt.m
  ./matlabPyrTools/spyrLev.m
  ./matlabPyrTools/spyrNumBands.m
  ./matlabPyrTools/steer.m
  ./matlabPyrTools/steer2HarmMtx.m
  ./matlabPyrTools/subMtx.m
  ./matlabPyrTools/upBlur.m
  ./matlabPyrTools/upConv.m
  ./matlabPyrTools/var2.m
  ./matlabPyrTools/vectify.m
  ./matlabPyrTools/wpyrBand.m
  ./matlabPyrTools/wpyrHt.m
  ./matlabPyrTools/wpyrLev.m
  ./matlabPyrTools/zconv2.m
  ./matrix/interleave_rows.m
  ./matrix/matrixnormalize.m
  ./matrix/msm_to_hb.m
  ./matrix/normalizerow.m
  ./matrix/normrow.m
  ./mesh/adjacency_list.m
  ./mesh/avgedge.m
  ./mesh/axisangle2quat.m
  ./mesh/barycenter.m
  ./mesh/biharmonic_distance.m
  ./mesh/biharmonic_embedding.m
  ./mesh/boundary_faces.m
  ./mesh/cage2tet.m
  ./mesh/cat_meshes.m
  ./mesh/catOBJs.m
  ./mesh/clean_tetgen_mesh.m
  ./mesh/combine.m
  ./mesh/commute_time_embedding.m
  ./mesh/cotmatrix.m
  ./mesh/cotmatrix3.m
  ./mesh/cotmatrix_intrinsic.m
  ./mesh/create_irregular_grid.m
  ./mesh/create_irregular_grid_with_min_angle.m
  ./mesh/create_regular_grid.m
  ./mesh/divmatrix.m
  ./mesh/doublearea.m
  ./mesh/dualquatlbs.m
  ./mesh/eat_comments.m
  ./mesh/edges.m
  ./mesh/execute_triangle.m
  ./mesh/faces_first.m
  ./mesh/getlayers.m
  ./mesh/getlayershe.m
  ./mesh/grad.m
  ./mesh/gradmatrix.m
  ./mesh/hds.m
  ./mesh/lbs.m
  ./mesh/limit_faces.m
  ./mesh/load_mesh.m
  ./mesh/loadBundle.m
  ./mesh/mask2poly.m
  ./mesh/massmatrix.m
  ./mesh/massmatrix3.m
  ./mesh/massmatrix_intrinsic.m
  ./mesh/neumannmatrix.m
  ./mesh/normals.m
  ./mesh/png2mesh.m
  ./mesh/png2objandtga.m
  ./mesh/png2poly.m
  ./mesh/point_inside_polygon.m
  ./mesh/poly2mesh.m
  ./mesh/print_poly.m
  ./mesh/print_to_poly_file.m
  ./mesh/printDiagonal.m
  ./mesh/printIJV.m
  ./mesh/project_point_to_line_segment.m
  ./mesh/quat2angle.m
  ./mesh/quat2mat.m
  ./mesh/quattrans2udq.m
  ./mesh/read_faces_from_ele_file.m
  ./mesh/read_poly.m
  ./mesh/read_vertices_from_node_file.m
  ./mesh/readBDLMeshChunk.m
  ./mesh/readELE.m
  ./mesh/readFACE.m
  ./mesh/readMESH.m
  ./mesh/readNODE.m
  ./mesh/readOBJ.m
  ./mesh/readOBJfast.m
  ./mesh/readOFF.m
  ./mesh/readTGF.m
  ./mesh/readWRL.m
  ./mesh/regular_tetrahedral_mesh.m
  ./mesh/rescaleOFF.m
  ./mesh/semiharmonic_embedding.m
  ./mesh/stacktimes.m
  ./mesh/stiffness_matrix.m
  ./mesh/tetgen.m
  ./mesh/tri2tet.m
  ./mesh/tri2tgf.m
  ./mesh/tricontour.m
  ./mesh/triharmonic_embedding.m
  ./mesh/triinterp.m
  ./mesh/triinterp_fail.m
  ./mesh/tsurf.m
  ./mesh/tt.m
  ./mesh/udq2quattrans.m
  ./mesh/union2tet.m
  ./mesh/upsample.m
  ./mesh/vtxpolyfit.m
  ./mesh/writeBDLChunkHeader.m
  ./mesh/writeBDLMeshChunk.m
  ./mesh/writeMESH.m
  ./mesh/writeNODE.m
  ./mesh/writeOBJ.m
  ./mesh/writeOFF.m
  ./mesh/writeTGF.m
  ./old/curve_editing_1d.m
  ./old/curve_editing_1d_system.m
  ./old/curve_editing_1d_system_fixed.m
  ./paths/depends.m
  ./plot/interactive_fit.m
  ./plot/interactive_fit_plot.m
  ./plot/myaa.m
  ./plot/vectarrow.m
  ./utility/progressbar.m


HELP DOCUMENTATION FOR EACH FILE
./dithering/average.m
  "average" dithering == thresholding on average


./dithering/comparison.m


./dithering/dither.m
  DITHER
 
  Dithers an input image
 
  D = dither(im,K) Image im is dither using algorithm specified by K:
    ['Floyd-Steinberg','Jarvis','Stucki','Sierra3','Sierra2','Sierra-lite',
     'Atkinson']
 
  D = dither(im,K,offset) Image im is dithered using provided error diffusion
    kernel K where current pixel is located in K by (1,1) + offset
 
  D = dither(im)  Image im is dithered using default algorithm
    {'Floyd-Steinberg'}
 


./dithering/hatch.m
  HATCH
 
  H = hatch(im,levels)
  Compute dithering hatched image with a number of levels.
 
  Inputs:
   im  original image
   levels  number of hatching levels {3}
   thickness  thickness of individual hatch lines
  Outputs:
   H  hatched image
 


./dithering/randdither.m


./geometry/slerp.m
  normalize a and b and keep 0's


./imageprocessing/denoise.m
  Given a noisy image and a similar prior image and the standard deviation of
  the noise (assumes gaussian distribution) denoise the iamge by building a
  steerable freq pyramid and using probabilistic algorithms to build a coring
  function (highest 5 bands only) to remap the image to the original. Also
  prints and shows plots of the estimators.
 
  Input:
   noisy_signal: image with noise
   prior: similar image without noise 
   standard_deviation_of_noise: the standard deviation of the noise
                                distribution
 
  Output:
   denoised: the denoised result image
   noise: the generated noise image
 


./imageprocessing/gray2rgb.m
  GRAY2RGB
 
  rgb = gray2rgb(im,map,n)
 
  Use a colormap, map, to convert a grayscale/intensity image with n colors
  to pseudocolor rgb image. The n colors in the original image are mapped
  evenly to colors in the given colormap, not according to value.
 
  rgb = gray2rgb(im,map)
 
  Same as above but compute number of colors in im
 
  rgb = gray2rgb(im)
 
  Use default colormap and compute number of colors in im
 
  Inputs:
   im  grayscale image, 2d array (h,w)
   map  colormap
   n  (optional) number of colors in im, default is to compute unique colors,
     this is usually preferred but it's time consuming so if the value is
     already known then it can be given.
  Outputs:
   rgb  color Red, Green, Blue image, 3d array (h,w,3)
 
  See also: rgb2gray, hsv2rgb, rgb2hsv, imshow
 


./imageprocessing/imnorm.m
  IMNORM
  
  N = imnorm(im)
 
  Normalize image to be between the range 0 and 1. Current just works with
  double images.
 
  Inputs:
    im  original input image
  Output:
    N  normalized image
 
 


./imageprocessing/imshow_before_and_after.m
  show a clip of two images x,y,w,h side by side in a window


./imageprocessing/imshow_rgb.m
  Wrapper for imshow taking R,G,B values separately


./imageprocessing/imtrim.m
 IMTRIM auto-crop an image like Photoshop's Edit>Trim feature, as of yet only
 grayscale imagse are supported
 
    cropped = IMTRIM(IM) crop image based on top left corner
    
    [cropped,t,b,l,r] = IMTRIM(IM) return cropped image and indices used to
    crop the image. So cropped = im(t:b,l:r);
 
    [t,b,l,r] = IMTRIM(IM) return only indices used to crop the image. So 
    cropped = im(t:b,l:r);
 
    [...] = IMTRIM(IM,location) same as above but location may specify
    top-left corner ('NorthWest') or bottom-right corner ('SouthEast') to be
    the picel used in determining the auto-crop
 
    Copyright Alec Jacobson, 2010
 


./imageprocessing/ziprgb.m
  Takes R,G,B as nxm matrices and makes rgb a nxmx3 3d-matrix


./matlabPyrTools/binomialFilter.m
  KERNEL = binomialFilter(size)
 
  Returns a vector of binomial coefficients of order (size-1) .


./matlabPyrTools/blur.m
  RES = blur(IM, LEVELS, FILT)
 
  Blur an image, by filtering and downsampling LEVELS times
  (default=1), followed by upsampling and filtering LEVELS times.  The
  blurring is done with filter kernel specified by FILT (default =
  'binom5'), which can be a string (to be passed to namedFilter), a
  vector (applied separably as a 1D convolution kernel in X and Y), or
  a matrix (applied as a 2D convolution kernel).  The downsampling is
  always by 2 in each direction.


./matlabPyrTools/blurDn.m
  RES = blurDn(IM, LEVELS, FILT)
 
  Blur and downsample an image.  The blurring is done with filter
  kernel specified by FILT (default = 'binom5'), which can be a string
  (to be passed to namedFilter), a vector (applied separably as a 1D
  convolution kernel in X and Y), or a matrix (applied as a 2D
  convolution kernel).  The downsampling is always by 2 in each
  direction.
 
  The procedure is applied recursively LEVELS times (default=1).


./matlabPyrTools/buildGpyr.m
  [PYR, INDICES] = buildGpyr(IM, HEIGHT, FILT, EDGES)
 
  Construct a Gaussian pyramid on matrix IM.
 
  HEIGHT (optional) specifies the number of pyramid levels to build. Default
  is 1+maxPyrHt(size(IM),size(FILT)). 
  You can also specify 'auto' to use this value.
 
  FILT (optional) can be a string naming a standard filter (see
  namedFilter), or a vector which will be used for (separable)
  convolution.  Default = 'binom5'.  EDGES specifies edge-handling, and
  defaults to 'reflect1' (see corrDn).
 
  PYR is a vector containing the N pyramid subbands, ordered from fine
  to coarse.  INDICES is an Nx2 matrix containing the sizes of
  each subband.  This is compatible with the MatLab Wavelet toolbox.


./matlabPyrTools/buildLpyr.m
  [PYR, INDICES] = buildLpyr(IM, HEIGHT, FILT1, FILT2, EDGES)
 
  Construct a Laplacian pyramid on matrix (or vector) IM.
 
  HEIGHT (optional) specifies the number of pyramid levels to build. Default
  is 1+maxPyrHt(size(IM),size(FILT)).  You can also specify 'auto' to
  use this value.
 
  FILT1 (optional) can be a string naming a standard filter (see
  namedFilter), or a vector which will be used for (separable)
  convolution.  Default = 'binom5'.  FILT2 specifies the "expansion"
  filter (default = filt1).  EDGES specifies edge-handling, and
  defaults to 'reflect1' (see corrDn).
 
  PYR is a vector containing the N pyramid subbands, ordered from fine
  to coarse.  INDICES is an Nx2 matrix containing the sizes of
  each subband.  This is compatible with the MatLab Wavelet toolbox.


./matlabPyrTools/buildSCFpyr.m
  [PYR, INDICES, STEERMTX, HARMONICS] = buildSCFpyr(IM, HEIGHT, ORDER, TWIDTH)
 
  This is a modified version of buildSFpyr, that constructs a
  complex-valued steerable pyramid  using Hilbert-transform pairs
  of filters.  Note that the imaginary parts will *not* be steerable.
 
  To reconstruct from this representation, either call reconSFpyr
  on the real part of the pyramid, *or* call reconSCFpyr which will
  use both real and imaginary parts (forcing analyticity).
 
  Description of this transform appears in: Portilla & Simoncelli,
  Int'l Journal of Computer Vision, 40(1):49-71, Oct 2000.
  Further information: http://www.cns.nyu.edu/~eero/STEERPYR/


./matlabPyrTools/buildSCFpyrLevs.m
  [PYR, INDICES] = buildSCFpyrLevs(LODFT, LOGRAD, XRCOS, YRCOS, ANGLE, HEIGHT, NBANDS)
 
  Recursive function for constructing levels of a steerable pyramid.  This
  is called by buildSCFpyr, and is not usually called directly.


./matlabPyrTools/buildSFpyr.m
  [PYR, INDICES, STEERMTX, HARMONICS] = buildSFpyr(IM, HEIGHT, ORDER, TWIDTH)
 
  Construct a steerable pyramid on matrix IM, in the Fourier domain.
  This is similar to buildSpyr, except that:
 
     + Reconstruction is exact (within floating point errors)
     + It can produce any number of orientation bands.
     - Typically slower, especially for non-power-of-two sizes.
     - Boundary-handling is circular.
 
  HEIGHT (optional) specifies the number of pyramid levels to build. Default
  is maxPyrHt(size(IM),size(FILT));
 
  The squared radial functions tile the Fourier plane, with a raised-cosine
  falloff.  Angular functions are cos(theta-k\pi/(K+1))^K, where K is
  the ORDER (one less than the number of orientation bands, default= 3).
 
  TWIDTH is the width of the transition region of the radial lowpass
  function, in octaves (default = 1, which gives a raised cosine for
  the bandpass filters).
 
  PYR is a vector containing the N pyramid subbands, ordered from fine
  to coarse.  INDICES is an Nx2 matrix containing the sizes of
  each subband.  This is compatible with the MatLab Wavelet toolbox.
  See the function STEER for a description of STEERMTX and HARMONICS.


./matlabPyrTools/buildSFpyrLevs.m
  [PYR, INDICES] = buildSFpyrLevs(LODFT, LOGRAD, XRCOS, YRCOS, ANGLE, HEIGHT, NBANDS)
 
  Recursive function for constructing levels of a steerable pyramid.  This
  is called by buildSFpyr, and is not usually called directly.


./matlabPyrTools/buildSpyr.m
  [PYR, INDICES, STEERMTX, HARMONICS] = buildSpyr(IM, HEIGHT, FILTFILE, EDGES)
 
  Construct a steerable pyramid on matrix IM.  Convolutions are
  done with spatial filters.
 
  HEIGHT (optional) specifies the number of pyramid levels to build. Default
  is maxPyrHt(size(IM),size(FILT)). 
  You can also specify 'auto' to use this value.
 
  FILTFILE (optional) should be a string referring to an m-file that
  returns the rfilters.  (examples: 'sp0Filters', 'sp1Filters',
  'sp3Filters','sp5Filters'.  default = 'sp1Filters'). EDGES specifies
  edge-handling, and defaults to 'reflect1' (see corrDn).
 
  PYR is a vector containing the N pyramid subbands, ordered from fine
  to coarse.  INDICES is an Nx2 matrix containing the sizes of
  each subband.  This is compatible with the MatLab Wavelet toolbox.
  See the function STEER for a description of STEERMTX and HARMONICS.


./matlabPyrTools/buildSpyrLevs.m
  [PYR, INDICES] = buildSpyrLevs(LOIM, HEIGHT, LOFILT, BFILTS, EDGES)
 
  Recursive function for constructing levels of a steerable pyramid.  This
  is called by buildSpyr, and is not usually called directly.


./matlabPyrTools/buildWpyr.m
  [PYR, INDICES] = buildWpyr(IM, HEIGHT, FILT, EDGES)
 
  Construct a separable orthonormal QMF/wavelet pyramid on matrix (or vector) IM.
 
  HEIGHT (optional) specifies the number of pyramid levels to build. Default
  is maxPyrHt(IM,FILT).  You can also specify 'auto' to use this value.
 
  FILT (optional) can be a string naming a standard filter (see
  namedFilter), or a vector which will be used for (separable)
  convolution.  Filter can be of even or odd length, but should be symmetric. 
  Default = 'qmf9'.  EDGES specifies edge-handling, and
  defaults to 'reflect1' (see corrDn).
 
  PYR is a vector containing the N pyramid subbands, ordered from fine
  to coarse.  INDICES is an Nx2 matrix containing the sizes of
  each subband.  This is compatible with the MatLab Wavelet toolbox.


./matlabPyrTools/cconv2.m
  RES = CCONV2(MTX1, MTX2, CTR)
 
  Circular convolution of two matrices.  Result will be of size of
  LARGER vector.
  
  The origin of the smaller matrix is assumed to be its center.
  For even dimensions, the origin is determined by the CTR (optional) 
  argument:
       CTR   origin
        0     DIM/2      (default)
        1     (DIM/2)+1  


./matlabPyrTools/clip.m
  [RES] = clip(IM, MINVALorRANGE, MAXVAL)
 
  Clip values of matrix IM to lie between minVal and maxVal:
       RES = max(min(IM,MAXVAL),MINVAL)
  The first argument can also specify both min and max, as a 2-vector.
  If only one argument is passed, the range defaults to [0,1].


./matlabPyrTools/Contents.m
  matlabPyrTools: Image and Multi-scale Pyramid Tools
  Version: 1.4, December-2009.
  Created: Early Spring, 1996. 
  Author:  Eero Simoncelli, eero.simoncelli@nyu.edu
 
  See README file for brief description.
  See ChangeLog file for latest modifications. 
  See TUTORIALS subdirectory for demonstrations.
  Type "help matlabPyrTools" to see this file as documentation.
  Type "help <command-name>" for documentation on individual commands.
  -----------------------------------------------------------------
  Synthetic Images (matrices):
    mkImpulse  - Make an image containing an impulse.
    mkRamp     - Make an image containing a ramp function.
    mkR        - Make an image containing distance from the origin.
    mkAngle    - Make an image containing angle about origin.
    mkDisc     - Make an image containing a disk image.
    mkGaussian - Make an image containing a Gaussian function.
    mkZonePlate - Make an image containing a zone plate (cos(r^2)).
    mkAngularSine - Make an image containing an angular sine wave (pinwheel).
    mkSine     - Make an image containing a sine grating.
    mkSquare   - Make an image containing a square grating.
    mkFract    - Make an image containing fractal (1/f) noise.
 
  Point Operations:
    clip       - clip values to a range. 
    pointOp    - Lookup table (much faster than interp1) [MEX file]
    histo      - Efficient histogram computation [MEX file]
    histoMatch - Modify matrix elements to match specified histogram stats.
 
  Convolution (first two are significantly faster):
    corrDn     - Correlate & downsample with boundary-handling [MEX file]
    upConv     - Upsample & convolve with boundary-handling [MEX file]
    blurDn     - Blur and subsample a signal/image.
    upBlur     - Upsample and blur a signal/image.
    blur       - Multi-scale blurring, calls blurDn and then upBlur.
    cconv2     - Circular convolution.
    rconv2     - Convolution with reflected boundaries.
    zconv2     - Convolution assuming zeros beyond image boundaries.
 
  General pyramids:
    pyrLow     - Access lowpass subband from (any type of) pyramid
    pyrBand    - Access a subband from (any type of) pyramid
    setPyrBand - Insert an image into (any type of) pyramid as a subband 
    pyrBandIndices - Returns indices for given band in a pyramid vector
    maxPyrHt   - compute maximum number of scales in a pyramid
 
  Gaussian/Laplacian Pyramids:
    buildGpyr  - Build a Gaussian pyramid of an input signal/image.
    buildLpyr  - Build a Laplacian pyramid of an input signal/image.
    reconLpyr  - Reconstruct (invert) the Laplacian pyramid transform.
 
  Separable orthonormal QMF/wavelet Pyramids:
    buildWpyr  - Build a separable wavelet representation of an input signal/image.
    reconWpyr  - Reconstruct (invert) the wavelet transform.
    wpyrBand   - Extract a single band of the wavelet representation.
    wpyrLev    - Extract (packed) subbands at a particular level
    wpyrHt     - Number of levels (height) of a wavelet pyramid.
 
  Steerable Pyramids:
    buildSpyr  - Build a steerable pyramid representation of an input image.
    reconSpyr  - Reconstruct (invert) the steerable pyramid transform.
    buildSFpyr - Build a steerable pyramid representation in the Fourier domain.
    reconSFpyr - Reconstruct (invert) the (Fourier domain) steerable pyramid transform.
    spyrBand   - Extract a single band from a steerable pyramid.
    spyrHigh   - Highpass residual band.
    spyrLev    - A whole level (i.e., all images at a given scale) of a steerable pyramid.
    spyrHt     - Number of levels (height) of a steerable pyramid.
    spyrNumBands - Number of orientation bands in a steerable pyramid.
 
  Steerable filters / derivatives:
    imGradient - Compute gradient of image using directionally accurete filters.
    steer      - Steer filters (or responses).
    steer2HarmMtx - Construct a matrix mapping direcional basis to angular harmonics. 
  
  Filters:
    binomialFilter  - returns a filter of binomial coefficients.
    namedFilter     - some typical Laplacian/Wavelet pyramid filters
    spNFilters      - Set of Nth order steerable pyramid filters.
    derivNFiltersS  - Matched set of S-tap 1D derivatives, orders 0 to N.
  
  Display:
    showIm     - Display a matrix (real or complex) as grayscale image(s).
                 Displays dimensions, subsampling, and range of pixel values.
    showLpyr   - Display a Laplacian pyramid.
    showWpyr   - Display a separable wavelet pyramid.
    showSpyr   - Display a steerable pyramid.
    lplot      - "lollipop" plot.
    nextFig    - Make next figure window current.
    pixelAxes  - Make image display use an integer number of pixels 
                 per sample to avoid resampling artifacts.
  
  Statistics (for 2D Matrices):
    range2     - Min and max of image (matrix) [MEX file]
    mean2      - Sample mean of an image (matrix). 
    var2       - Sample variance of an image (matrix). 
    skew2      - Sample skew (3rd moment / variance^1.5) of an image (matrix). 
    kurt2      - Sample kurtosis (4th moment / variance^2) of an image (matrix). 
    entropy2   - Sample entropy of an image (matrix).
    imStats    - Report sample statistics of an image, or pair of images.
 
  Miscellaneous:
    pgmRead    - Load a "pgm" image into a MatLab matrix [try einstein.pgm,feynman.pgm]
    pgmWrite   - Write a MatLab matrix to a "pgm" image file.
    shift      - circular shift a 2D matrix by an arbitrary amount.
    vectify    - pack matrix into column vector (i.e., function to compute mtx(:)).
    ifftshift  - inverse of MatLab's FFTSHIFT (differs for odd-length dimensions)
    rcosFn     - return a lookup table of a raised-cosine threshold fn.
    innerProd  - Compute M'*M efficiently (i.e., do not copy) [MEX file]


./matlabPyrTools/corrDn.m
  RES = corrDn(IM, FILT, EDGES, STEP, START, STOP)
 
  Compute correlation of matrices IM with FILT, followed by
  downsampling.  These arguments should be 1D or 2D matrices, and IM
  must be larger (in both dimensions) than FILT.  The origin of filt
  is assumed to be floor(size(filt)/2)+1.
  
  EDGES is a string determining boundary handling:
     'circular' - Circular convolution
     'reflect1' - Reflect about the edge pixels
     'reflect2' - Reflect, doubling the edge pixels
     'repeat'   - Repeat the edge pixels
     'zero'     - Assume values of zero outside image boundary
     'extend'   - Reflect and invert (continuous values and derivs)
     'dont-compute' - Zero output when filter overhangs input boundaries
 
  Downsampling factors are determined by STEP (optional, default=[1 1]), 
  which should be a 2-vector [y,x].
  
  The window over which the convolution occurs is specfied by START 
  (optional, default=[1,1], and STOP (optional, default=size(IM)).
  
  NOTE: this operation corresponds to multiplication of a signal
  vector by a matrix whose rows contain copies of the FILT shifted by
  multiples of STEP.  See upConv.m for the operation corresponding to
  the transpose of this matrix.


./matlabPyrTools/entropy2.m
  E = ENTROPY2(MTX,BINSIZE) 
  
  Compute the first-order sample entropy of MTX.  Samples of VEC are
  first discretized.  Optional argument BINSIZE controls the
  discretization, and defaults to 256/(max(VEC)-min(VEC)).
 
  NOTE: This is a heavily biased estimate of entropy (it is too
  small) when you don't have much data!


./matlabPyrTools/factorial.m
  RES = factorial(NUM)
 
  Factorial function that works on matrices (matlab's does not).


./matlabPyrTools/histo.m
  [N,X] = histo(MTX, nbinsOrBinsize, binCenter);
 
  Compute a histogram of (all) elements of MTX.  N contains the histogram
  counts, X is a vector containg the centers of the histogram bins.
 
  nbinsOrBinsize (optional, default = 101) specifies either
  the number of histogram bins, or the negative of the binsize.
 
  binCenter (optional, default = mean2(MTX)) specifies a center position
  for (any one of) the histogram bins.
 
  How does this differ from MatLab's HIST function?  This function:
    - allows uniformly spaced bins only.
    +/- operates on all elements of MTX, instead of columnwise.
    + is much faster (approximately a factor of 80 on my machine).
    + allows specification of number of bins OR binsize.  Default=101 bins.
    + allows (optional) specification of binCenter.


./matlabPyrTools/histoMatch.m
  RES = histoMatch(MTX, N, X)
 
  Modify elements of MTX so that normalized histogram matches that
  specified by vectors X and N, where N contains the histogram counts
  and X the histogram bin positions (see histo).


./matlabPyrTools/imGradient.m
  [dx, dy] = imGradient(im, edges) 
 
  Compute the gradient of the image using smooth derivative filters
  optimized for accurate direction estimation.  Coordinate system
  corresponds to standard pixel indexing: X axis points rightward.  Y
  axis points downward.  EDGES specify boundary handling (see corrDn
  for options).
 
  Unlike matlab's new gradient function, which is based on local
  differences, this function computes derivatives using 5x5 filters
  designed to accurately reflect the local orientation content.


./matlabPyrTools/imStats.m
  imStats(IM1,IM2)
 
  Report image (matrix) statistics.
  When called on a single image IM1, report min, max, mean, stdev, skew,
  and kurtosis (4th moment about the mean, divided by squared variance)
 
  When called on two images (IM1 and IM2), report min, max, mean, 
  stdev of the difference, and also SNR (relative to IM1).


./matlabPyrTools/innerProd.m
  RES = innerProd(MTX)
 
  Compute (MTX' * MTX) efficiently (i.e., without copying the matrix)
 
  NOTE: This function used to call a MEX function (C code) to avoid copying, but
  newer versions of matlab have eliminated the overhead of the
  simpler form below. 


./matlabPyrTools/kurt2.m
  K = KURT2(MTX,MEAN,VAR)
 
  Sample kurtosis (fourth moment divided by squared variance) 
  of a matrix.  Kurtosis of a Gaussian distribution is 3.
   MEAN (optional) and VAR (optional) make the computation faster.


./matlabPyrTools/lplot.m
  lplot(VEC, XRANGE)
 
  Plot VEC, a vector, in  "lollipop" format.  
  XRANGE (optional, default = [1,length(VEC)]), should be a 2-vector 
  specifying the X positions (for labeling purposes) of the first and 
  last sample of VEC.


./matlabPyrTools/lpyrHt.m
  [HEIGHT] = lpyrHt(INDICES)
 
  Compute height of Laplacian pyramid with given its INDICES matrix.
  See buildLpyr.m


./matlabPyrTools/maxPyrHt.m
  HEIGHT = maxPyrHt(IMSIZE, FILTSIZE)
 
  Compute maximum pyramid height for given image and filter sizes.
  Specifically: the number of corrDn operations that can be sequentially
  performed when subsampling by a factor of 2.


./matlabPyrTools/mean2.m
  M = MEAN2(MTX)
 
  Sample mean of a matrix.


./matlabPyrTools/mkAngle.m
  IM = mkAngle(SIZE, PHASE, ORIGIN)
 
  Compute a matrix of dimension SIZE (a [Y X] 2-vector, or a scalar)
  containing samples of the polar angle (in radians, CW from the
  X-axis, ranging from -pi to pi), relative to angle PHASE (default =
  0), about ORIGIN pixel (default = (size+1)/2).


./matlabPyrTools/mkAngularSine.m
  IM = mkAngularSine(SIZE, HARMONIC, AMPL, PHASE, ORIGIN)
 
  Make an angular sinusoidal image:
      AMPL * sin( HARMONIC*theta + PHASE),
  where theta is the angle about the origin.
  SIZE specifies the matrix size, as for zeros().  
  AMPL (default = 1) and PHASE (default = 0) are optional.


./matlabPyrTools/mkDisc.m
  IM = mkDisc(SIZE, RADIUS, ORIGIN, TWIDTH, VALS)
 
  Make a "disk" image.  SIZE specifies the matrix size, as for
  zeros().  RADIUS (default = min(size)/4) specifies the radius of 
  the disk.  ORIGIN (default = (size+1)/2) specifies the 
  location of the disk center.  TWIDTH (in pixels, default = 2) 
  specifies the width over which a soft threshold transition is made.
  VALS (default = [0,1]) should be a 2-vector containing the
  intensity value inside and outside the disk.  


./matlabPyrTools/mkFract.m
  IM = mkFract(SIZE, FRACT_DIM)
 
  Make a matrix of dimensions SIZE (a [Y X] 2-vector, or a scalar)
  containing fractal (pink) noise with power spectral density of the
  form: 1/f^(5-2*FRACT_DIM).  Image variance is normalized to 1.0.
  FRACT_DIM defaults to 1.0


./matlabPyrTools/mkGaussian.m
  IM = mkGaussian(SIZE, COVARIANCE, MEAN, AMPLITUDE)
  
  Compute a matrix with dimensions SIZE (a [Y X] 2-vector, or a
  scalar) containing a Gaussian function, centered at pixel position
  specified by MEAN (default = (size+1)/2), with given COVARIANCE (can
  be a scalar, 2-vector, or 2x2 matrix.  Default = (min(size)/6)^2),
  and AMPLITUDE.  AMPLITUDE='norm' (default) will produce a
  probability-normalized function.  All but the first argument are
  optional.


./matlabPyrTools/mkImpulse.m
  IM = mkImpulse(SIZE, ORIGIN, AMPLITUDE)
 
  Compute a matrix of dimension SIZE (a [Y X] 2-vector, or a scalar)
  containing a single non-zero entry, at position ORIGIN (defaults to
  ceil(size/2)), of value AMPLITUDE (defaults to 1).


./matlabPyrTools/mkR.m
  IM = mkR(SIZE, EXPT, ORIGIN)
  
  Compute a matrix of dimension SIZE (a [Y X] 2-vector, or a scalar)
  containing samples of a radial ramp function, raised to power EXPT
  (default = 1), with given ORIGIN (default = (size+1)/2, [1 1] =
  upper left).  All but the first argument are optional.


./matlabPyrTools/mkRamp.m
  IM = mkRamp(SIZE, DIRECTION, SLOPE, INTERCEPT, ORIGIN)
 
  Compute a matrix of dimension SIZE (a [Y X] 2-vector, or a scalar)
  containing samples of a ramp function, with given gradient DIRECTION
  (radians, CW from X-axis, default = 0), SLOPE (per pixel, default =
  1), and a value of INTERCEPT (default = 0) at the ORIGIN (default =
  (size+1)/2, [1 1] = upper left).  All but the first argument are
  optional.


./matlabPyrTools/mkSine.m
  IM = mkSine(SIZE, PERIOD, DIRECTION, AMPLITUDE, PHASE, ORIGIN)
       or
  IM = mkSine(SIZE, FREQ, AMPLITUDE, PHASE, ORIGIN)
  
  Compute a matrix of dimension SIZE (a [Y X] 2-vector, or a scalar)
  containing samples of a 2D sinusoid, with given PERIOD (in pixels),
  DIRECTION (radians, CW from X-axis, default = 0), AMPLITUDE (default
  = 1), and PHASE (radians, relative to ORIGIN, default = 0).  ORIGIN
  defaults to the center of the image.
  
  In the second form, FREQ is a 2-vector of frequencies (radians/pixel).


./matlabPyrTools/mkSquare.m
  IM = mkSquare(SIZE, PERIOD, DIRECTION, AMPLITUDE, PHASE, ORIGIN, TWIDTH)
       or
  IM = mkSine(SIZE, FREQ, AMPLITUDE, PHASE, ORIGIN, TWIDTH)
  
  Compute a matrix of dimension SIZE (a [Y X] 2-vector, or a scalar)
  containing samples of a 2D square wave, with given PERIOD (in
  pixels), DIRECTION (radians, CW from X-axis, default = 0), AMPLITUDE
  (default = 1), and PHASE (radians, relative to ORIGIN, default = 0).
  ORIGIN defaults to the center of the image.  TWIDTH specifies width
  of raised-cosine edges on the bars of the grating (default =
  min(2,period/3)).
  
  In the second form, FREQ is a 2-vector of frequencies (radians/pixel).


./matlabPyrTools/mkZonePlate.m
  IM = mkZonePlate(SIZE, AMPL, PHASE)
 
  Make a "zone plate" image:
      AMPL * cos( r^2 + PHASE)
  SIZE specifies the matrix size, as for zeros().  
  AMPL (default = 1) and PHASE (default = 0) are optional.


./matlabPyrTools/modulateFlip.m
  [HFILT] = modulateFlipShift(LFILT)
 
  QMF/Wavelet highpass filter construction: modulate by (-1)^n,
  reverse order (and shift by one, which is handled by the convolution
  routines).  This is an extension of the original definition of QMF's
  (e.g., see Simoncelli90).


./matlabPyrTools/namedFilter.m
  KERNEL = NAMED_FILTER(NAME)
 
  Some standard 1D filter kernels.  These are scaled such that
  their L2-norm is 1.0.
 
   binomN             - binomial coefficient filter of order N-1
   haar:              - Haar wavelet.
   qmf8, qmf12, qmf16 - Symmetric Quadrature Mirror Filters [Johnston80]
   daub2,daub3,daub4  - Daubechies wavelet [Daubechies88].
   qmf5, qmf9, qmf13: - Symmetric Quadrature Mirror Filters [Simoncelli88,Simoncelli90]
 
   See bottom of file for full citations.


./matlabPyrTools/nextFig.m
  nextFig (MAXFIGS, SKIP)
  
  Make figure number mod((GCF+SKIP), MAXFIGS) the current figure.
  MAXFIGS is optional, and defaults to 2.
  SKIP is optional, and defaults to 1.


./matlabPyrTools/pgmRead.m
  IM = pgmRead( FILENAME )
 
  Load a pgm image into a MatLab matrix.  
    This format is accessible from the XV image browsing utility.
    Only works for 8bit gray images (raw or ascii)


./matlabPyrTools/pgmWrite.m
  RANGE = pgmWrite(MTX, FILENAME, RANGE, TYPE, COMMENT)
 
  Write a MatLab matrix to a pgm (graylevel image) file.
  This format is accessible from the XV image browsing utility.
 
  RANGE (optional) is a 2-vector specifying the values that map to
  black and white, respectively.  Passing a value of 'auto' (default)
  sets RANGE=[min,max] (as in MatLab's imagesc).  'auto2' sets
  RANGE=[mean-2*stdev, mean+2*stdev].  'auto3' sets
  RANGE=[p1-(p2-p1)/8, p2+(p2-p1)/8], where p1 is the 10th percentile
  value of the sorted MATRIX samples, and p2 is the 90th percentile
  value.
 
  TYPE (optional) should be 'raw' or 'ascii'.  Defaults to 'raw'.


./matlabPyrTools/pixelAxes.m
  [ZOOM] = pixelAxes(DIMS, ZOOM)
 
  Set the axes of the current plot to cover a multiple of DIMS pixels,
  thereby eliminating screen aliasing artifacts when displaying an
  image of size DIMS.  
  
  ZOOM (optional, default='same') expresses the desired number of
  samples displayed per screen pixel.  It should be a scalar, which
  will be rounded to the nearest integer, or 1 over an integer.  It
  may also be the string 'same' or 'auto', in which case the value is chosen so
  as to produce an image closest in size to the currently displayed
  image.  It may also be the string 'full', in which case the image is
  made as large as possible while still fitting in the window.


./matlabPyrTools/pointOp.m
  RES = pointOp(IM, LUT, ORIGIN, INCREMENT, WARNINGS)
 
  Apply a point operation, specified by lookup table LUT, to image IM.
  LUT must be a row or column vector, and is assumed to contain
  (equi-spaced) samples of the function.  ORIGIN specifies the
  abscissa associated with the first sample, and INCREMENT specifies the
  spacing between samples.  Between-sample values are estimated via
  linear interpolation.  If WARNINGS is non-zero, the function prints
  a warning whenever the lookup table is extrapolated.
 
  This function is much faster than MatLab's interp1, and allows
  extrapolation beyond the lookup table domain.  The drawbacks are
  that the lookup table must be equi-spaced, and the interpolation is
  linear.


./matlabPyrTools/pwd2path.m
  PWD2PATH()
 
  add current working directory (pwd) to path.


./matlabPyrTools/pyrBand.m
  RES = pyrBand(PYR, INDICES, BAND_NUM)
 
  Access a subband from a pyramid (gaussian, laplacian, QMF/wavelet, 
  or steerable).  Subbands are numbered consecutively, from finest
  (highest spatial frequency) to coarsest (lowest spatial frequency).


./matlabPyrTools/pyrBandIndices.m
  RES = pyrBandIndices(INDICES, BAND_NUM)
 
  Return indices for accessing a subband from a pyramid 
  (gaussian, laplacian, QMF/wavelet, steerable).


./matlabPyrTools/pyrLow.m
  RES = pyrLow(PYR, INDICES)
 
  Access the lowpass subband from a pyramid 
    (gaussian, laplacian, QMF/wavelet, steerable).


./matlabPyrTools/range2.m
  [MIN, MAX] = range2(MTX)
 
  Compute minimum and maximum values of MTX, returning them as a 2-vector.


./matlabPyrTools/rconv2.m
  RES = RCONV2(MTX1, MTX2, CTR)
 
  Convolution of two matrices, with boundaries handled via reflection
  about the edge pixels.  Result will be of size of LARGER matrix.
  
  The origin of the smaller matrix is assumed to be its center.
  For even dimensions, the origin is determined by the CTR (optional) 
  argument:
       CTR   origin
        0     DIM/2      (default)
        1     (DIM/2)+1  


./matlabPyrTools/rcosFn.m
  [X, Y] = rcosFn(WIDTH, POSITION, VALUES)
 
  Return a lookup table (suitable for use by INTERP1) 
  containing a "raised cosine" soft threshold function:
  
     Y =  VALUES(1) + (VALUES(2)-VALUES(1)) *
               cos^2( PI/2 * (X - POSITION + WIDTH)/WIDTH )
 
  WIDTH is the width of the region over which the transition occurs
  (default = 1). POSITION is the location of the center of the
  threshold (default = 0).  VALUES (default = [0,1]) specifies the
  values to the left and right of the transition.


./matlabPyrTools/reconLpyr.m
  RES = reconLpyr(PYR, INDICES, LEVS, FILT2, EDGES)
 
  Reconstruct image from Laplacian pyramid, as created by buildLpyr.
 
  PYR is a vector containing the N pyramid subbands, ordered from fine
  to coarse.  INDICES is an Nx2 matrix containing the sizes of
  each subband.  This is compatible with the MatLab Wavelet toolbox.
 
  LEVS (optional) should be a list of levels to include, or the string
  'all' (default).  The finest scale is number 1.  The lowpass band
  corresponds to lpyrHt(INDICES)+1.
 
  FILT2 (optional) can be a string naming a standard filter (see
  namedFilter), or a vector which will be used for (separable)
  convolution.  Default = 'binom5'.  EDGES specifies edge-handling,
  and defaults to 'reflect1' (see corrDn).


./matlabPyrTools/reconSCFpyr.m
  RES = reconSCFpyr(PYR, INDICES, LEVS, BANDS, TWIDTH)
 
  The inverse of buildSCFpyr: Reconstruct image from its complex steerable pyramid representation,
  in the Fourier domain.
 
  The image is reconstructed by forcing the complex subbands to be analytic
  (zero on half of the 2D Fourier plane, as they are supossed to be unless
  they have being modified), and reconstructing from the real part of those
  analytic subbands. That is equivalent to compute the Hilbert transforms of
  the imaginary parts of the subbands, average them with their real
  counterparts, and then reconstructing from the resulting real subbands.
 
  PYR is a vector containing the N pyramid subbands, ordered from fine
  to coarse.  INDICES is an Nx2 matrix containing the sizes of
  each subband.  This is compatible with the MatLab Wavelet toolbox.
 
  LEVS (optional) should be a list of levels to include, or the string
  'all' (default).  0 corresonds to the residual highpass subband.
  1 corresponds to the finest oriented scale.  The lowpass band
  corresponds to number spyrHt(INDICES)+1.
 
  BANDS (optional) should be a list of bands to include, or the string
  'all' (default).  1 = vertical, rest proceeding anti-clockwise.
 
  TWIDTH is the width of the transition region of the radial lowpass
  function, in octaves (default = 1, which gives a raised cosine for
  the bandpass filters).


./matlabPyrTools/reconSFpyr.m
  RES = reconSFpyr(PYR, INDICES, LEVS, BANDS, TWIDTH)
 
  Reconstruct image from its steerable pyramid representation, in the Fourier
  domain, as created by buildSFpyr.
 
  PYR is a vector containing the N pyramid subbands, ordered from fine
  to coarse.  INDICES is an Nx2 matrix containing the sizes of
  each subband.  This is compatible with the MatLab Wavelet toolbox.
 
  LEVS (optional) should be a list of levels to include, or the string
  'all' (default).  0 corresonds to the residual highpass subband.  
  1 corresponds to the finest oriented scale.  The lowpass band
  corresponds to number spyrHt(INDICES)+1.
 
  BANDS (optional) should be a list of bands to include, or the string
  'all' (default).  1 = vertical, rest proceeding anti-clockwise.
 
  TWIDTH is the width of the transition region of the radial lowpass
  function, in octaves (default = 1, which gives a raised cosine for
  the bandpass filters).


./matlabPyrTools/reconSFpyrLevs.m
  RESDFT = reconSFpyrLevs(PYR,INDICES,LOGRAD,XRCOS,YRCOS,ANGLE,NBANDS,LEVS,BANDS)
 
  Recursive function for reconstructing levels of a steerable pyramid
  representation.  This is called by reconSFpyr, and is not usually
  called directly.


./matlabPyrTools/reconSpyr.m
  RES = reconSpyr(PYR, INDICES, FILTFILE, EDGES, LEVS, BANDS)
 
  Reconstruct image from its steerable pyramid representation, as created
  by buildSpyr.
 
  PYR is a vector containing the N pyramid subbands, ordered from fine
  to coarse.  INDICES is an Nx2 matrix containing the sizes of
  each subband.  This is compatible with the MatLab Wavelet toolbox.
 
  FILTFILE (optional) should be a string referring to an m-file that returns
  the rfilters.  examples: sp0Filters, sp1Filters, sp3Filters 
  (default = 'sp1Filters'). 
  EDGES specifies edge-handling, and defaults to 'reflect1' (see
  corrDn).
  
  LEVS (optional) should be a list of levels to include, or the string
  'all' (default).  0 corresonds to the residual highpass subband.  
  1 corresponds to the finest oriented scale.  The lowpass band
  corresponds to number spyrHt(INDICES)+1.
 
  BANDS (optional) should be a list of bands to include, or the string
  'all' (default).  1 = vertical, rest proceeding anti-clockwise.


./matlabPyrTools/reconSpyrLevs.m
  RES = reconSpyrLevs(PYR,INDICES,LOFILT,BFILTS,EDGES,LEVS,BANDS)
 
  Recursive function for reconstructing levels of a steerable pyramid
  representation.  This is called by reconSpyr, and is not usually
  called directly.


./matlabPyrTools/reconWpyr.m
  RES = reconWpyr(PYR, INDICES, FILT, EDGES, LEVS, BANDS)
 
  Reconstruct image from its separable orthonormal QMF/wavelet pyramid
  representation, as created by buildWpyr.
 
  PYR is a vector containing the N pyramid subbands, ordered from fine
  to coarse.  INDICES is an Nx2 matrix containing the sizes of
  each subband.  This is compatible with the MatLab Wavelet toolbox.
 
  FILT (optional) can be a string naming a standard filter (see
  namedFilter), or a vector which will be used for (separable)
  convolution.  Default = 'qmf9'.  EDGES specifies edge-handling,
  and defaults to 'reflect1' (see corrDn).
 
  LEVS (optional) should be a vector of levels to include, or the string
  'all' (default).  1 corresponds to the finest scale.  The lowpass band
  corresponds to wpyrHt(INDICES)+1.
 
  BANDS (optional) should be a vector of bands to include, or the string
  'all' (default).   1=horizontal, 2=vertical, 3=diagonal.  This is only used
  for pyramids of 2D images.


./matlabPyrTools/setPyrBand.m
  NEWPYR = setPyrBand(PYR, INDICES, NEWBAND, BAND_NUM)
 
  Insert an image (BAND) into a pyramid (gaussian, laplacian, QMF/wavelet, 
  or steerable).  Subbands are numbered consecutively, from finest
  (highest spatial frequency) to coarsest (lowest spatial frequency).


./matlabPyrTools/shift.m
  [RES] = shift(MTX, OFFSET)
  
  Circular shift 2D matrix samples by OFFSET (a [Y,X] 2-vector),
  such that  RES(POS) = MTX(POS-OFFSET).


./matlabPyrTools/showIm.m
  RANGE = showIm (MATRIX, RANGE, ZOOM, LABEL, NSHADES )
  
  Display a MatLab MATRIX as a grayscale image in the current figure,
  inside the current axes.  If MATRIX is complex, the real and imaginary 
  parts are shown side-by-side, with the same grayscale mapping.
  
  If MATRIX is a string, it should be the name of a variable bound to a 
  MATRIX in the base (global) environment.  This matrix is displayed as an 
  image, with the title set to the string.
  
  RANGE (optional) is a 2-vector specifying the values that map to
  black and white, respectively.  Passing a value of 'auto' (default)
  sets RANGE=[min,max] (as in MatLab's imagesc).  'auto2' sets
  RANGE=[mean-2*stdev, mean+2*stdev].  'auto3' sets
  RANGE=[p1-(p2-p1)/8, p2+(p2-p1)/8], where p1 is the 10th percentile
  value of the sorted MATRIX samples, and p2 is the 90th percentile
  value.
  
  ZOOM specifies the number of matrix samples per screen pixel.  It
  will be rounded to an integer, or 1 divided by an integer.  A value
  of 'same' or 'auto' (default) causes the zoom value to be chosen
  automatically to fit the image into the current axes.  A value of
  'full' fills the axis region (leaving no room for labels).  See
  pixelAxes.m.
  
  If LABEL (optional, default = 1, unless zoom='full') is non-zero, the range 
  of values that are mapped into the gray colormap and the dimensions 
  (size) of the matrix and zoom factor are printed below the image.  If label 
  is a string, it is used as a title.
  
  NSHADES (optional) specifies the number of gray shades, and defaults
  to the size of the current colormap.


./matlabPyrTools/showLpyr.m
  RANGE = showLpyr (PYR, INDICES, RANGE, GAP, LEVEL_SCALE_FACTOR)
  
  Display a Laplacian (or Gaussian) pyramid, specified by PYR and
  INDICES (see buildLpyr), in the current figure.
  
  RANGE is a 2-vector specifying the values that map to black and
  white, respectively.  These values are scaled by
  LEVEL_SCALE_FACTOR^(lev-1) for bands at each level.  Passing a value
  of 'auto1' sets RANGE to the min and max values of MATRIX.  'auto2'
  sets RANGE to 3 standard deviations below and above 0.0.  In both of
  these cases, the lowpass band is independently scaled.  A value of
  'indep1' sets the range of each subband independently, as in a call
  to showIm(subband,'auto1').  Similarly, 'indep2' causes each subband
  to be scaled independently as if by showIm(subband,'indep2').
  The default value for RANGE is 'auto1' for 1D images, and 'auto2' for
  2D images.
  
  GAP (optional, default=1) specifies the gap in pixels to leave
  between subbands (2D images only).  
  
  LEVEL_SCALE_FACTOR indicates the relative scaling between pyramid
  levels.  This should be set to the sum of the kernel taps of the
  lowpass filter used to construct the pyramid (default assumes
  L2-normalalized filters, using a value of 2 for 2D images, sqrt(2) for
  1D images).


./matlabPyrTools/showSpyr.m
  RANGE = showSpyr (PYR, INDICES, RANGE, GAP, LEVEL_SCALE_FACTOR)
  
  Display a steerable pyramid, specified by PYR and INDICES
  (see buildSpyr), in the current figure.  The highpass band is not shown.
  
  RANGE is a 2-vector specifying the values that map to black and
  white, respectively.  These values are scaled by
  LEVEL_SCALE_FACTOR^(lev-1) for bands at each level.  Passing a value
  of 'auto1' sets RANGE to the min and max values of MATRIX.  'auto2'
  sets RANGE to 3 standard deviations below and above 0.0.  In both of
  these cases, the lowpass band is independently scaled.  A value of
  'indep1' sets the range of each subband independently, as in a call
  to showIm(subband,'auto1').  Similarly, 'indep2' causes each subband
  to be scaled independently as if by showIm(subband,'indep2').
  The default value for RANGE is 'auto2'.
  
  GAP (optional, default=1) specifies the gap in pixels to leave
  between subbands.  
  
  LEVEL_SCALE_FACTOR indicates the relative scaling between pyramid
  levels.  This should be set to the sum of the kernel taps of the
  lowpass filter used to construct the pyramid (default is 2, which is 
  correct for L2-normalized filters.


./matlabPyrTools/showWpyr.m
  RANGE = showWpyr (PYR, INDICES, RANGE, GAP, LEVEL_SCALE_FACTOR)
  
  Display a separable QMF/wavelet pyramid, specified by PYR and INDICES
  (see buildWpyr), in the current figure.
  
  RANGE is a 2-vector specifying the values that map to black and
  white, respectively.  These values are scaled by
  LEVEL_SCALE_FACTOR^(lev-1) for bands at each level.  Passing a value
  of 'auto1' sets RANGE to the min and max values of MATRIX.  'auto2'
  sets RANGE to 3 standard deviations below and above 0.0.  In both of
  these cases, the lowpass band is independently scaled.  A value of
  'indep1' sets the range of each subband independently, as in a call
  to showIm(subband,'auto1').  Similarly, 'indep2' causes each subband
  to be scaled independently as if by showIm(subband,'indep2').
  The default value for RANGE is 'auto1' for 1D images, and 'auto2' for
  2D images.
  
  GAP (optional, default=1) specifies the gap in pixels to leave
  between subbands (2D images only).  
  
  LEVEL_SCALE_FACTOR indicates the relative scaling between pyramid
  levels.  This should be set to the sum of the kernel taps of the
  lowpass filter used to construct the pyramid (default assumes
  L2-normalized filters, using a value of 2 for 2D images, sqrt(2) for
  1D images).


./matlabPyrTools/skew2.m
  S = SKEW2(MTX,MEAN,VAR)
 
  Sample skew (third moment divided by variance^3/2) of a matrix.
   MEAN (optional) and VAR (optional) make the computation faster.


./matlabPyrTools/sp0Filters.m
  Steerable pyramid filters.  Transform described  in:
 
  @INPROCEEDINGS{Simoncelli95b,
 	TITLE = "The Steerable Pyramid: A Flexible Architecture for
 		 Multi-Scale Derivative Computation",
 	AUTHOR = "E P Simoncelli and W T Freeman",
 	BOOKTITLE = "Second Int'l Conf on Image Processing",
 	ADDRESS = "Washington, DC", MONTH = "October", YEAR = 1995 }
 
  Filter kernel design described in:
 
 @INPROCEEDINGS{Karasaridis96,
 	TITLE = "A Filter Design Technique for 
 		Steerable Pyramid Image Transforms",
 	AUTHOR = "A Karasaridis and E P Simoncelli",
 	BOOKTITLE = "ICASSP",	ADDRESS = "Atlanta, GA",
 	MONTH = "May",	YEAR = 1996 }


./matlabPyrTools/sp1Filters.m
  Steerable pyramid filters.  Transform described  in:
 
  @INPROCEEDINGS{Simoncelli95b,
 	TITLE = "The Steerable Pyramid: A Flexible Architecture for
 		 Multi-Scale Derivative Computation",
 	AUTHOR = "E P Simoncelli and W T Freeman",
 	BOOKTITLE = "Second Int'l Conf on Image Processing",
 	ADDRESS = "Washington, DC", MONTH = "October", YEAR = 1995 }
 
  Filter kernel design described in:
 
 @INPROCEEDINGS{Karasaridis96,
 	TITLE = "A Filter Design Technique for 
 		Steerable Pyramid Image Transforms",
 	AUTHOR = "A Karasaridis and E P Simoncelli",
 	BOOKTITLE = "ICASSP",	ADDRESS = "Atlanta, GA",
 	MONTH = "May",	YEAR = 1996 }


./matlabPyrTools/sp3Filters.m
  Steerable pyramid filters.  Transform described  in:
 
  @INPROCEEDINGS{Simoncelli95b,
 	TITLE = "The Steerable Pyramid: A Flexible Architecture for
 		 Multi-Scale Derivative Computation",
 	AUTHOR = "E P Simoncelli and W T Freeman",
 	BOOKTITLE = "Second Int'l Conf on Image Processing",
 	ADDRESS = "Washington, DC", MONTH = "October", YEAR = 1995 }
 
  Filter kernel design described in:
 
 @INPROCEEDINGS{Karasaridis96,
 	TITLE = "A Filter Design Technique for 
 		Steerable Pyramid Image Transforms",
 	AUTHOR = "A Karasaridis and E P Simoncelli",
 	BOOKTITLE = "ICASSP",	ADDRESS = "Atlanta, GA",
 	MONTH = "May",	YEAR = 1996 }


./matlabPyrTools/sp5Filters.m
  Steerable pyramid filters.  Transform described  in:
 
  @INPROCEEDINGS{Simoncelli95b,
 	TITLE = "The Steerable Pyramid: A Flexible Architecture for
 		 Multi-Scale Derivative Computation",
 	AUTHOR = "E P Simoncelli and W T Freeman",
 	BOOKTITLE = "Second Int'l Conf on Image Processing",
 	ADDRESS = "Washington, DC", MONTH = "October", YEAR = 1995 }
 
  Filter kernel design described in:
 
 @INPROCEEDINGS{Karasaridis96,
 	TITLE = "A Filter Design Technique for 
 		Steerable Pyramid Image Transforms",
 	AUTHOR = "A Karasaridis and E P Simoncelli",
 	BOOKTITLE = "ICASSP",	ADDRESS = "Atlanta, GA",
 	MONTH = "May",	YEAR = 1996 }


./matlabPyrTools/spyrBand.m
  [LEV,IND] = spyrBand(PYR,INDICES,LEVEL,BAND)
 
  Access a band from a steerable pyramid.
  
    LEVEL indicates the scale (finest = 1, coarsest = spyrHt(INDICES)).
  
    BAND (optional, default=1) indicates which subband 
      (1 = vertical, rest proceeding anti-clockwise).


./matlabPyrTools/spyrHigh.m
  RES = spyrHigh(PYR, INDICES)
 
  Access the highpass residual band from a steerable pyramid.


./matlabPyrTools/spyrHt.m
  [HEIGHT] = spyrHt(INDICES)
 
  Compute height of steerable pyramid with given index matrix.


./matlabPyrTools/spyrLev.m
  [LEV,IND] = spyrLev(PYR,INDICES,LEVEL)
 
  Access a level from a steerable pyramid.
  Return as an SxB matrix, B = number of bands, S = total size of a band.
  Also returns an Bx2 matrix containing dimensions of the subbands.


./matlabPyrTools/spyrNumBands.m
  [NBANDS] = spyrNumBands(INDICES)
 
  Compute number of orientation bands in a steerable pyramid with
  given index matrix.  If the pyramid contains only the highpass and
  lowpass bands (i.e., zero levels), returns 0.


./matlabPyrTools/steer.m
  RES = STEER(BASIS, ANGLE, HARMONICS, STEERMTX)
 
  Steer BASIS to the specfied ANGLE.  
  
  BASIS should be a matrix whose columns are vectorized rotated copies of a 
  steerable function, or the responses of a set of steerable filters.
  
  ANGLE can be a scalar, or a column vector the size of the basis.
  
  HARMONICS (optional, default is N even or odd low frequencies, as for 
  derivative filters) should be a list of harmonic numbers indicating
  the angular harmonic content of the basis.
  
  STEERMTX (optional, default assumes cosine phase harmonic components,
  and filter positions at 2pi*n/N) should be a matrix which maps
  the filters onto Fourier series components (ordered [cos0 cos1 sin1 
  cos2 sin2 ... sinN]).  See steer2HarmMtx.m


./matlabPyrTools/steer2HarmMtx.m
  MTX = steer2HarmMtx(HARMONICS, ANGLES, REL_PHASES)
 
  Compute a steering matrix (maps a directional basis set onto the
  angular Fourier harmonics).  HARMONICS is a vector specifying the
  angular harmonics contained in the steerable basis/filters.  ANGLES 
  (optional) is a vector specifying the angular position of each filter.  
  REL_PHASES (optional, default = 'even') specifies whether the harmonics 
  are cosine or sine phase aligned about those positions.
  The result matrix is suitable for passing to the function STEER.


./matlabPyrTools/subMtx.m
  MTX = subMtx(VEC, DIMENSIONS, START_INDEX)
 
  Reshape a portion of VEC starting from START_INDEX (optional,
  default=1) to the given dimensions.


./matlabPyrTools/upBlur.m
  RES = upBlur(IM, LEVELS, FILT)
 
  Upsample and blur an image.  The blurring is done with filter
  kernel specified by FILT (default = 'binom5'), which can be a string
  (to be passed to namedFilter), a vector (applied separably as a 1D
  convolution kernel in X and Y), or a matrix (applied as a 2D
  convolution kernel).  The downsampling is always by 2 in each
  direction.
 
  The procedure is applied recursively LEVELS times (default=1).


./matlabPyrTools/upConv.m
  RES = upConv(IM, FILT, EDGES, STEP, START, STOP, RES)
 
  Upsample matrix IM, followed by convolution with matrix FILT.  These
  arguments should be 1D or 2D matrices, and IM must be larger (in
  both dimensions) than FILT.  The origin of filt
  is assumed to be floor(size(filt)/2)+1.
 
  EDGES is a string determining boundary handling:
     'circular' - Circular convolution
     'reflect1' - Reflect about the edge pixels
     'reflect2' - Reflect, doubling the edge pixels
     'repeat'   - Repeat the edge pixels
     'zero'     - Assume values of zero outside image boundary
     'extend'   - Reflect and invert
     'dont-compute' - Zero output when filter overhangs OUTPUT boundaries
 
  Upsampling factors are determined by STEP (optional, default=[1 1]),
  a 2-vector [y,x].
  
  The window over which the convolution occurs is specfied by START 
  (optional, default=[1,1], and STOP (optional, default = 
  step .* (size(IM) + floor((start-1)./step))).
 
  RES is an optional result matrix.  The convolution result will be 
  destructively added into this matrix.  If this argument is passed, the 
  result matrix will not be returned. DO NOT USE THIS ARGUMENT IF 
  YOU DO NOT UNDERSTAND WHAT THIS MEANS!!
  
  NOTE: this operation corresponds to multiplication of a signal
  vector by a matrix whose columns contain copies of the time-reversed
  (or space-reversed) FILT shifted by multiples of STEP.  See corrDn.m
  for the operation corresponding to the transpose of this matrix.


./matlabPyrTools/var2.m
  V = VAR2(MTX,MEAN)
 
  Sample variance of a matrix.
   Passing MEAN (optional) makes the calculation faster.


./matlabPyrTools/vectify.m
  [VEC] = columnize(MTX)
  
  Pack elements of MTX into a column vector.  Just provides a
  function-call notatoin for the operation MTX(:)


./matlabPyrTools/wpyrBand.m
  RES = wpyrBand(PYR, INDICES, LEVEL, BAND)
 
  Access a subband from a separable QMF/wavelet pyramid.  
  
  LEVEL (optional, default=1) indicates the scale (finest = 1,
  coarsest = wpyrHt(INDICES)).  
  
  BAND (optional, default=1) indicates which subband (1=horizontal,
  2=vertical, 3=diagonal).


./matlabPyrTools/wpyrHt.m
  [HEIGHT] = wpyrHt(INDICES)
 
  Compute height of separable QMF/wavelet pyramid with given index matrix.


./matlabPyrTools/wpyrLev.m
  [LEV,IND] = wpyrLev(PYR,INDICES,LEVEL)
 
  Access a level from a separable QMF/wavelet pyramid.
  Return as an SxB matrix, B = number of bands, S = total size of a band.
  Also returns an Bx2 matrix containing dimensions of the subbands.


./matlabPyrTools/zconv2.m
  RES = ZCONV2(MTX1, MTX2, CTR)
 
  Convolution of two matrices, with boundaries handled as if the larger mtx
  lies in a sea of zeros. Result will be of size of LARGER vector.
  
  The origin of the smaller matrix is assumed to be its center.
  For even dimensions, the origin is determined by the CTR (optional) 
  argument:
       CTR   origin
        0     DIM/2      (default)
        1     (DIM/2)+1  (behaves like conv2(mtx1,mtx2,'same'))


./matrix/interleave_rows.m
  Takes two nxm matrices and creates a 2nxm matrix such that even rows are
  from the first matrix and odd rows are from the second.
 
  Input:
   A First nxm matrix, top row of output will be same as top of this matrix
     along with every other row
   B Second nxm matrix, bottom row of output will be same as bottom of this
     matrix along with every other row
 
  Ouput:
   C 2nxm matrix, alternating rows
 
 


./matrix/matrixnormalize.m
  MATRIXNORMALIZE
  
  N = matrixnormalize(M)
 
  Normalize matrix values to be between the range 0 and 1. Current just works with
  matrices of type double.
 
  Inputs:
    M  original input matrix
  Output:
    N  normalized matrix
 
 


./matrix/msm_to_hb.m
 *****************************************************************************80
 
 % MSM_TO_HB writes a MATLAB Sparse Matrix to a Harwell Boeing Sparse Matrix file.
 
   Usage: 
 
     For full control:
 
       msm_to_hb ( output_filename, A, rhs, 'title', 'key', 'type', ifmt, job ) 
 
     or, to use defaults:
 
       msm_to_hb ( output_filename, A )
 
   Modified:
 
     28 April 2004
 
   Author:
 
     Xiaoye Li, UC Berkeley. 
 
   Parameters:
 
     Input, string OUTPUT_FILENAME, the name of the file to which the information
     should be written.
 
     Input, sparse matrix A, the NROW by NCOL matrix, stored in MATLAB sparse 
     matrix format, which is to be written to the file.
 
     Input, real RHS(NRHS,NROW), the right-hand side array, accessed only if ( 2 < JOB).
 
     Input, string TITLE, a title of up to 72 characters.
     TITLE defaults to 'Title'.
 
     Input, string KEY, a key for the matrix, of up to 8 characters.
     KEY defaults to 'Key'.
 
     Input, string TYPE, the HB type for the matrix, of exactly 3 characters.
     TYPE defaults to 'RUA' (real, unsymmetric, assembled).
 
     Input, integer IFMT, specifies the output format of the numerical values.
     * IFMT < 100 chooses the format Dxx.yy, in which yy is precisely IFMT 
       and xx is IFMT+7.
     * 100 < IFMT chooses the format Fxx.yy, in which the length of the mantissa 
       yy is the integer mod(ifmt,100) and the length of the integer part is IFMT/100.
     For example:
     * IFMT =   4 means  E11.4   [-]x.xxxxE+ee    
     * IFMT = 104 means  F7.4    [-]x.xxxx
     IFMT defaults to 8.
 
     Input, integer JOB, indicates what is to be written out.
     * 1, write structure only, the index arrays JA and IA.
     * 2, write structure and matrix, A, JA, IA
     * 3, write structure, matrix, and one right hand side: A, JA, IA, RHS.
     * K+2, write structure, matrix and K successive right-hand sides.
     JOB defaults to 2.
 


./matrix/normalizerow.m
  NORMALIZEROW 
 
  Normalize each row
 
  [ A ] = normalizerow( A )
 
  Input:
   A  #A by D list of row vectors of dimension D
  Output:
   B  #B by D list of normalized row vectors 


./matrix/normrow.m
  NORMROW 
 
  B = normrow( A )
 
  Input:
   A  #A by D list of row vectors of dimension D
  Output:
   B  #B list of norms of row vectors in A


./mesh/adjacency_list.m


./mesh/avgedge.m
  AVGEDGE
 
  Compute the average of every edge in the mesh
 
  Inputs:
   V  #V x 3 matrix of vertex coordinates
   F  #F x 3  matrix of indices of triangle corners
  Outputs:
   b average edge length
 
  Note: boundary edges are weighted half as much as internal edges


./mesh/axisangle2quat.m
  AXISANGLE2QUAT
 
  Q = axisangle2quat(W,TH)
  
  Convert axis angle representation of rotation to quaternion
 
  Inputs:
    W  list of axes, #rotations by 3
    TH  list of angles, #rotations by 1
  Outputs:
   Q  list of rotations stored as quaternions, one for each control
     #rotations by 4 (1,i,j,k) 


./mesh/barycenter.m
  BARYCENTER
 
  B = barycenter(V,F)
 
  Compute the barycenter of every triangle
 
  Inputs:
    V #V x 3 matrix of vertex coordinates
    F #F x 3  matrix of indices of triangle corners
  Output:
    B a #F x 3 matrix of 3d vertices


./mesh/biharmonic_distance.m
  [D] = biharmonic_distance(V,F,i,dim)
 
  Takes a mesh (V,F) and returns a distance field D from all points in V to
  the ith vertex, according to the biharmonic embedding
 
  Input:
    V  vertex list
    F  face list
    i  index of vertex from which to calculate distances
    dim  requested dimension of the embedding
  Output:
    D  biharmonic distance field 
  


./mesh/biharmonic_embedding.m
  [B,V,D] = biharmonic_embedding(V,F);
 
  Takes a mesh (V,F) and returns an embedding using the spectrum of the
  biharmonic operator. Then the biharmonic distance between two points i and
  j can be computed as the euclidean distance between B(i,:) and B(j,:),
  namely: 
    dist_ij = sqrt(sum((B(i,:)-B(j,:)).^2,2));
  
  Input:
    V  vertex list
    F  face list
    dim requested dimension of the embedding
  Output:
    B  biharmonic embedding
    V  eigenvectors used in embedding
    D  eigenvalues used in embedding
  


./mesh/boundary_faces.m
  BOUNDARY_FACES
  F = boundary_faces(T)
  Determine boundary faces of tetrahedra stored in T
 
  Input:
   T  tetrahedron index list, m by 4, where m is the number of tetrahedra
 
  Output:
   F  list of boundary faces, n by 3, where n is the number of boundary faces
 


./mesh/cage2tet.m
  CAGE2TET
 
  Script to make a 3d tet mesh from a 2d surface cage and a 2d surface
  residing in the cage. Faces of the resulting .mesh file are the faces of
  the original internal surface though they may not correspond to faces of
  tets
 
  Inputs:
    cage_name name of the file containing cage vertices and faces, should be off
      or obj
    surface_name  name of the file containing the internal surface vertices
      and faces
    output_name  name of file to be written with tet mesh
 


./mesh/cat_meshes.m
  CAT_MESHES concatenate two meshes
 
  [V,F] = cat_meshes(F1,V1,F2,V2)
 


./mesh/catOBJs.m


./mesh/clean_tetgen_mesh.m
  CLEAN_TETGEN_MESH
  clean_tetgen_mesh(input_file,output_file)
  TetGen writes ALL triangles to the .mesh file, that is all faces of the
  tetrahedra in the 3D mesh. clean_tetgen_mesh(input_file,output_file) reads
  the vertices and tetrahedra in input_file (ignoring triangles) and
  determines the surfaces triangles then write the vertices, surfaces
  triangles and tetrahedra to output_file
 
  Input:
    input_file  path to .mesh file containing vertices and tetrahedra
    output_file  path to .mesh file to be written
  


./mesh/combine.m
  Two meshes where the second mesh was constructed as the surface of the
  union of the volume of the first mesh and a third mesh. The order of
  vertices is such that the first chunk of vertices in the second mesh is a
  subsequence of vertices in the first mesh (the remaining chunks are a
  subsequence of vertices from the third mesh, then new vertices). The goal is
  to create a new mesh where the vertices are: all the vertices from the first
  mesh then other vertices and faces from the second mesh. This means in the
  resulting mesh the unreferenced vertices correspond to vertices that were in
  the first mesh but not in the second mesh.
  
  Inputs:
    IV  vertex list of the first mesh
    IF  face list of the first mesh
    EV  vertex list of the second mesh
    EF  face list of the second mesh
  Outputs:
    OV  vertex list of the output mesh
    OF  face list of the output mesh
  


./mesh/commute_time_embedding.m
  [C,V,D] = commute_time_embedding(V,F);
 
  Takes a mesh (V,F) and returns an embedding using the spectrum of the
  harmonic operator. Then the commute time distance between two points i and
  j can be computed as the euclidean distance between C(i,:) and C(j,:),
  namely: 
    dist_ij = sqrt(sum((C(i,:)-C(j,:)).^2,2));
  We also once referred to this as "harmonic embedding" because "Biharmonic
  Distance" uses an embedding where the eigenvalues in the denominator are
  squared, hence that was the "biharmonic embedding", thus this could be the
  "harmonic embedding". Not to be confused with the embedding used in
  diffusion distance.
  
  Input:
    V  vertex list
    F  face list
    dim requested dimension of the embedding
  Output:
    C  commute time embedding
    V  eigenvectors used in embedding
    D  eigenvalues used in embedding
  


./mesh/cotmatrix.m
  COTMATRIX
 
  L = cotmatrix(V,F)
  Inputs:
    V  #V x 3 matrix of vertex coordinates
    F  #F x 3  matrix of indices of triangle corners
  Outputs:
    L  sparse #V x #V matrix of cot weights 
 


./mesh/cotmatrix3.m
  COTMATRIX3
 
  Following definition that appears in the appendix of:
  ``Interactive Topology-aware Surface Reconstruction,'' by Sharf, A. et al
  http://www.cs.bgu.ac.il/~asharf/Projects/InSuRe/Insure_siggraph_final.pdf
 
  K = cotmatrix(V,T)
  V:  #V x 3 matrix of vertex coordinates
  T:  #T x 4  matrix of indices of tetrahedral corners
  returns  #V x #V matrix of cot weights 
 
  See also cotmatrix


./mesh/cotmatrix_intrinsic.m
  COTMATRIX_INTRINSIC
 
  L = cotmatrix(l,F,nvert)
 
  Inputs:
   l: #F by 3, array of edge lengths of edges opposite each face in F
   F: #F by 3, list of indices of triangle corners
   nvert: number of vertices, only needed to set size
  Outputs:
    L  sparse nvert x nvert matrix of cot weights 
 
  See also: cotmatrix


./mesh/create_irregular_grid.m
  creates random UV positions and their connectivity information.
 
  Usage:
    [UV,F,res] = create_irregular_grid(xRes, yRes, n, wrapX, wrapY)
 
  Input:
     n: number of points to create per block
     wrapX, wrapY: wrap around in X/Y direction
  Output:
    UV: UV coordinates in interval [0,1]x[0,1]
    F : mesh connectivity (triangles)


./mesh/create_irregular_grid_with_min_angle.m
  creates random UV positions and their connectivity information guaranteeing
  min angle by wrapping trianlge (http://www.cs.cmu.edu/~quake/triangle.html)
 
  Usage:
    [V,F] = create_irregular_grid_with_min_angle(xRes, yRes, n, xWrap, yWrap)
 
  Input:
     n: number of points to create per block
     xWrap, yWrap: wrap around in X/Y direction
     min_angle: minimum angle between edges
     no_interior: don't generate an interior before sending to triangle
     dart_threshold: controls variation from regular
     


./mesh/create_regular_grid.m
  Creates list of triangle vertex indices for a rectangular domain,
  optionally wrapping around in X/Y direction.
 
  Usage:
    [UV,F,res,edge_norms] = create_regular_grid(xRes, yRes, xWrap, yWrap)
 
  Input:
    xRes, yRes: number of points in X/Y direction
    wrapX, wrapY: wrap around in X/Y direction
    near, far: near and far should be fractions of one which control the
               pinching of the domain at the center and sides
 
  Output:
    F : mesh connectivity (triangles)
    UV: UV coordinates in interval [0,1]x[0,1]
    res: mesh resolution


./mesh/divmatrix.m
  D = gradmatrix(V,F)
  V:  #V x 3 matrix of vertex coordinates
  F:  3 x #F  matrix of indices of triangle corners
  returns  #V x #V matrix of grad weights


./mesh/doublearea.m
  DOUBLEAREA
 
  [ dblA ] = areas( V, F )
 
  Compute the areas of the triangles of a mesh
 
  Inputs:
   V #V x 3 matrix of vertex coordinates
   F #F x 3  matrix of indices of triangle corners
  Outputs:
   dblA   #F list of twice the area of each corresponding face
 
  See also: massmatrix


./mesh/dualquatlbs.m
  DUALQUATLBS
 
  [U] = dualquatlbs(V,DQ,W)
  
  Compute dual quaternions linear blend skinning deformation of vertices V,
  using rigid transformations stored as dual quaternions, DQ, at some control
  points, propogated to the mesh using weights W.
  
  Inputs:
   V  list of vertex positions
   DQ  list of rigid transformations for each control point stored as dual
     quaternions
     2 by 4 by #controls
   W  weights, # vertices by # handles matrix of weights
  Output:
   U  list of new vertex positions
 


./mesh/eat_comments.m
  EAT_COMMENTS 
  use fscanf to eat lines starting with a comment_symbol


./mesh/edges.m
  EDGES Compute the edges of a mesh
 
  Input:
   F #F x 3  matrix of indices of triangle corners
  Output:
   E edges in sorted order, direction of each is also sorted
 
  Example:
    % get unique undirected edges
    E = edges(F);
    % get unique directed edges
    E = [E ; E(:,2) E(:, 1)];
  


./mesh/execute_triangle.m
  execute the util triangle (http://www.cs.cmu.edu/~quake/triangle.html)
  with the given command line arguements
 
  Input:
  command_line_args: string of command line arguments
 
  Outputs:
    V  #vertices by 2, list of vertex positions
    F  #faces by 3, list of face indices
 


./mesh/faces_first.m
  FACES_FIRST
  [RT,RV,RF,IM] = faces_first(T,V,F);
  Reorder vertices so that vertices in face list come before vertices that
  don't appear in the face list. This is especially useful if the face list
  contains only surface faces and you want surface vertices listed before
  internal vertices
  Input:
   T  # tetrahedra by 4 list of tetrahedra indices
   V  # vertices by 3 vertex positions
   F  # faces by 3 list of face indices
  Output: 
   RT  # tetrahedra by 4 list of tetrahedra indices, reindexed to use RV
   RV  # vertices by 3 vertex positions, order such that if the jth vertex is
     some face in F, and the kth vertex is not then j comes before k
   RF  # faces by 3 list of face indices, reindexed to use RV
   IM  # faces by 1 list of indices such that: RF = IM(F) and RT = IM(T)
     and RV(IM,:) = V
 


./mesh/getlayers.m
  function [layers,interior] = getlayers(mesh, nlayers)
  mesh:     mesh struct
  nlayers:  number of layers to get, >= 1
  returns cell array of index sets for layers 1.. k, and index set for interior
  layers are defined recursively as
  layer(1) = vertices on the boundary
  layer(i) = vertices edge-adjacent to layer(i-1)


./mesh/getlayershe.m
  Does the same as getlayers except instead of finding layers by shrinking from
  boundary it expects mesh.layers to already contain the proper indices. So
  that this function just sets layershe properly
  
  function [layers,interior] = getlayers(mesh, nlayers)
  mesh:     mesh half-edge struct
  nlayers:  number of layers to get, >= 1
  returns cell array of index sets for layers 1.. k, and index set for interior
  layers are defined recursively as
  layer(1) = vertices on the boundary
  layer(i) = vertices edge-adjacent to layer(i-1)


./mesh/grad.m
  GRAD
  G = grad(V,F,X)
 
  Compute the numerical gradient at every face of a triangle mesh.
 
  Inputs:
    V  #vertices by 3 list of mesh vertex positions
    F  #faces by 3 list of mesh face indices
    X  # vertices list of scalar function values
  Outputs:
    G  #faces by 3 list of gradient values
 


./mesh/gradmatrix.m
  G = gradmatrix(V,F)
  V:  #V x 3 matrix of vertex coordinates
  F:  3 x #F  matrix of indices of triangle corners
  N:  #N x 1 list of indices for which we want G
  returns  #E x #V matrix of grad equations
  where #E is the number of edges in region of N


./mesh/hds.m
  Halfedge datastructure from the list of triangles 
  mesh is assumed to be orientable, and triangle vertices enumerated 
  consistently counter-clockwise about a consistently chosen normal direction, 
  i.e, if two triangles share  the edge (i1,i2), the order of i1 and i2 in 
  the vertex list is (i1,i2) for one triangle and the opposite for the
  other.
 
  Halfege = edge + orientation; by convention, associated with the face
  for which traversal from tail to tip agrees with the order of vertices
  in the face list.
 
  All connectivity information is represented conceptually by 
  relationship between halfedges, and these are used as handles for 
  vertices and faces; i.e., to refer to a vertex v we use one of the 
  halfedges such that tip(he) = v, same for faces
 
  for each halfedge, we support the following const-time operations: 
  -- next halfedge around assoc. face
  -- prev halfedge around assoc. face
  -- opposite halfedge (i.e., the other halfedge for the same edge)
  -- tail and tip vertices 
  -- associated face
 
 prev(he1)\  he2face(he1)       /
           \       he1         / next(he1)
   tail(he1)*---------------->* tip(he1)
            <----------------
           /      opp(he1)   \
  
   border edges have special halfedges on one side, which do not have
   the associated face.
 
   this file implements the halfedge data structure for triangle meshes
   only.
 


./mesh/lbs.m
  LBS
 
  [U] = lbs(V,T,W)
 
  Compute linear blend skinning deformation of vertices V, using
  transformations at some control points T, propogated to the mesh using
  weights W.
  
  Inputs:
   V  list of vertex positions
   T  list of transformations for each controls point, for 2D:
     2 by 3 by #controls, for 3D: 3 x 4 by # controls
   W  weights, # vertices by # handles matrix of weights
  Output:
   U  list of new vertex positions
 


./mesh/limit_faces.m
  limit faces F to L 


./mesh/load_mesh.m
  read in vertices and faces from a .off or .obj file
  Input:
    filename  file holding mesh
  Output:
    V (vertex list) 
    F (face list) fields


./mesh/loadBundle.m
  bundle  =  loadBundle(filename)
  read a bundle from a file 


./mesh/mask2poly.m
 http://ltfat.sourceforge.net/


./mesh/massmatrix.m
  M = massmatrix(V,F, type)
 
  mass matrix for the mesh given by V and F
 
  Inputs:
   V  #V x 3 matrix of vertex coordinates
   F  #F x 3  matrix of indices of triangle corners
   type  string containing type of mass matrix to compute
    'full': full mass matrix for p.w. linear fem
    'barycentric': diagonal lumped mass matrix obtained by summing 1/3
    'voronoi': true voronoi area, except in cases where triangle is obtuse
      then uses 1/2, 1/4, 1/4
 
  Output:
   M  #V by #V sparse mass matrix


./mesh/massmatrix3.m
  MASSMATRIX3
 
  M = massmatrix(V,T, type)
 
  mass matrix for the mesh given by V and F
 
  Inputs:
    V #V x 3 matrix of vertex coordinates
    T #T x 4  matrix of indices of tetrahedral corners
    type  string containing type of mass matrix to compute
      'barycentric': diagonal lumped mass matrix obtained by summing 1/3
        of volumes of surrounding tets
      Not yet supported:
        'full': full mass matrix for p.w. linear fem
        'voronoi'
  Output:
    M  #V x #V matrix of cot weights 


./mesh/massmatrix_intrinsic.m
  MASSMATRIX_INTRINSIC
 
  [M] = massmatrix_intrinsic(l,F)
 
  compute the mass matrix from edge lengths only
 
  Inputs:
   l: #F by 3, array of edge lengths of edges opposite each face in F
   F: #F by 3, list of indices of triangle corners
   nvert: number of vertices, only needed to set size
   masstype: full, barycentric, or voronoi
  TODO: this is almost identical to massmatrix, 
  only the area computation is different, need to refactor
 
  here's a handy line to view mass matrix entries on plot:
  text(UV(:,1), UV(:,2),zeros(size(UV,1),1),num2str(M(M>0)))
 
  See also: massmatrix


./mesh/neumannmatrix.m
  [Nu,Nv] = neumannmatrix(mmesh,V)
  returns two sparse matrices of size #V x #V;
  the only nonzero columns/rows are for boundary vertices.
  The indices used in the matrix match the original indices. 
  If the derivatives gradx_u = dx/du and gradx_v = dx/dv of the unknown x
  are given at vertices of the boundary, we interpolate them linearly
  and compute the vector withe entries 
  <dx/dn phi_j>,  as \sum_i <gradx dot t_ij, phi_j> = 
  = \sum_i gradx_i dot t_ij <phi_i phi_j> = 
  = (Nu gradx_u + Nv gradx_v)_j, where phi_i are hats on the boundary
  and t_ij are outward perpendiculars to the boundary edges


./mesh/normals.m
  NORMALS 
 
  N = normals(V,F)
 
  Compute normals per face
 
  Inputs:
   V  #V x 3 matrix of vertex coordinates
   F  #F x 3  matrix of indices of triangle corners
  Output:
   N  #F x 3 list of face normals
 


./mesh/png2mesh.m
  PNG2MESH
 
  [V,F] = png2mesh(filename, laplacian_smoothness_iterations,
  max_points_on_boundary)
 
  Mesh the non transparent part of an image. Best to have the entire shape
  surrounded by at least one transparent pixel. Also the outer boundary and
  boundary of holes should be roughly the same size as resampling to meet the
  max_points_on_boundary parameter is done by edge collapsing on the boundary
  (small boundaries will end up with too many samples and therefor the
  triangulation will be dense there).
  
  Inputs:
    filename  path to .png file
    laplacian_smoothness_iterations  Number of iterations of laplacian
      smoothing of the positions of boundary curve points before handing
      curve to Triangle
    max_points_on_boundary  maximum number of points in the input curve
      before handing to Triangle
  Outputs:
    V  #vertices by 2, list of vertex positions
    F  #faces by 3, list of face indices
 


./mesh/png2objandtga.m
 function png2objandtga(filename,laplacian_smoothness_iterations,max_points_on_boundary)


./mesh/png2poly.m
 function [poly] = 
  png2poly(filename,laplacian_smoothing_iterations,max_points,output_filename)
 
  mask2poly supports holey alpha masks so this could, too but for now doesn't
 
 
  for a 400x88 png I've found laplacian_smoothing_iterations = 100 works pretty
  well
  for a 400x88 png I've found max_points= 100 works pretty
  well
 


./mesh/point_inside_polygon.m
 function interior_point = point_inside_polygon(V)
 
  Input
   V n by 2 vertex array
 


./mesh/poly2mesh.m
  POLY2MESH
 
  [V,F] = poly2mesh(filename,minimum_angle,maximum_area)
  
  Triangulate interoir of polygon read from .poly file using Triangle
 
  Inputs:
   filename  path to .poly file
   minimum_angle  minimum angle parameter for Triangle
   maximum_area  maximum area parameter for Triangle
 
  Outputs:
    V  #vertices by 2, list of vertex positions
    F  #faces by 3, list of face indices
 


./mesh/print_poly.m
  prints a vertices to a .poly file, with segments connecting those vertices
 
  Input
    poly:      struct array where each element contains fields:
                     x,y,hole
    poly_file_name:  name of output file as string (caution! will clobber
                     existing)
 


./mesh/print_to_poly_file.m
  prints a vertices to a .poly file, with segments connecting those vertices
 
  Input
    V:               list of vertex positions (2d)
    segments:        list of segments (vertex index pairs)
    poly_file_name:  name of output file as string (caution! will clobber
                     existing)
 


./mesh/printDiagonal.m


./mesh/printIJV.m


./mesh/project_point_to_line_segment.m
  returns q the closest point to p on the line segment from A to B 


./mesh/quat2angle.m
  [R] = quat2mat(q)
  Input:
    q is an m by 4 list of normalized quaternions
  Output:
    R is a list of m rotation matrices
 
 % [r1,r2,r3] = quat2angle(q)
 % Input:
 %   q is an m by 4 list of normalized quaternions
 % Output:
 %   r1 is list of m rotations about z-axis (yaw)
 %   r2 is list of m rotations about y-axis (pitch)
 %   r3 is list of m rotations about x-axis (roll)
 % See:
 %   http://en.wikipedia.org/wiki/
 %   Conversion_between_quaternions_and_Euler_angles#Conversion
 %
   r1 = atan2(2*(q(:,1).*q(:,4) + q(:,2).*q(:,3)),1-2*(q(:,3).^2+q(:,4).^2));
   r2 = asin(2*(q(:,1).*q(:,3) - q(:,4).*q(:,2)));
   r3 = atan2(2*(q(:,1).*q(:,2) + q(:,3).*q(:,4)),1-2*(q(:,2).^2+q(:,3).^2));


./mesh/quat2mat.m
  QUAT2MAT
 
  [R] = quat2mat(q)
 
  Input:
    q is an m by 4 list of normalized quaternions
  Output:
    R is a 4 by 4 by m list of rotation matrices
 
  See:
    http://en.wikipedia.org/wiki/
    Conversion_between_quaternions_and_Euler_angles#Rotation_matrices
 


./mesh/quattrans2udq.m
  QUATTRANS2UDQ
 
  UDQ = quattrans2udq(Q,T)
 
  Convert a rotation stored as a quaternion and a translation to a dual
  quaternion
  Inputs:
   Q  list of rotations stored as quaternions, one for each control
     #controls by 4 (1,i,j,k) 
   T  list of translations stored as vectors, one for each control
     #controls by 3
  Output:
   UDQ  list of rigid transformations for each control point stored as dual
     quaternions
     2 by 4 #controls
 


./mesh/read_faces_from_ele_file.m
  read face connectivity information from a standard .ele file (output of
  executing 'triangle'
 
  Input:
    ele_file_name: name of .ele file
 


./mesh/read_poly.m
  reads vertices to a .poly file, with segments connecting those vertices
 
  Input
    poly_file_name:  name of output file as string (caution! will clobber
                     existing)
  Output
    poly:      struct array where each element contains fields:
                     x,y,hole
 


./mesh/read_vertices_from_node_file.m
  read vertex position information from a standard .node file (output of
  executing 'triangle'
 
  Input:
    node_file_name: name of .node file
 


./mesh/readBDLMeshChunk.m
  read a mesh chunk from a file stream 
 
  Usage:
     mesh = readMeshChunk( fp)
 
  mesh fields: 
  V  (required)  vertices
  F              faces
  col            colors
  baseColor      a single color for the whole mesh
  UV             uv coords


./mesh/readELE.m
  READELE
  E = readELE(ele_file_name)
  Read (face or tet) elements from a .ele file, used by Stellar and Triangle
  
  Input:
    ele_file_name  path to .ele file
 
  Output:
    E  list of element indices (1-indexed), could be triangles or tets based
      on header of .ele file
 
  See also readNODE
 


./mesh/readFACE.m
  READFACE
  F = readFACE(filename)
 
  Read triangular faces from a .face file
  Input:
   filename  name of .face file
  Output:
   F  list of triangle indices


./mesh/readMESH.m
  readMESH reads an MESH file with vertex/face/tet information
 
  [V,T,F] = readMESH( filename )
 
  Input:
   filename  path to .mesh file
  Outputs:
   V  #V by 3 list of vertices
   T  #T by 4 list of tet indices
   F  #F by 3 list of triangle indices
 


./mesh/readNODE.m
  READNODE
  V = readNODE(node_file_name)
 
  Read vertex positions from .node file, .node files are used by Stellar and
  Triangle
 
  Input:
   node_file_name  path to .node file
 
  Output:
   V  list of vertex positions
 
  See also readELE
 


./mesh/readOBJ.m
  READOBJ reads an OBJ file with vertex/face information
 
  [V,F,UV] = readOBJ( filename )
 
  Input:
   filename  path to .obj file
  Outputs:
   V  #V by 3 list of vertices
   F  #F by 3 list of triangle indices
   UV  #V by 2 list of texture coordinates
 
 
  WARNING: This is at least 40 times slower than readOFF but probably much much
  slower...
 
  See also: readOBJfast


./mesh/readOBJfast.m
  readOBJfast
 
  reads an OBJ file quickly, but OBJ file should be formated *simply*
 
  Input:
   filename  path to .obj file
  Outputs:
   V  #V by 3 list of vertices
   F  #F by 3 list of triangle indices
 
  filename should be a text file containing first vertex positions where each
  line is:
  v x y z
  then a list of faces where each line is:
  f i j k
  and exactly that. Any lines before vertices, or after vertices but before
  faces are ignored. Comments throughout vetex and face lines will surely
  break this.
 
 
  For complete(r) support use readOBJ
  
  See also readOBJ
 


./mesh/readOFF.m
  READOFF reads an OFF file with vertex/face information
 
  [V,F,UV,C,N] = readOFF( filename )
 
  Input:
   filename  path to .obj file
  Outputs:
   V  #V by 3 list of vertices
   F  #F by 3 list of triangle indices
   UV  #V by 2 list of texture coordinates
   C  #V by 3 list of colors
   N  #V by 3 list of normals


./mesh/readTGF.m
  READTGF
 
  [V,E] = readTGF(filename)
 
  Read a graph from a .tgf file
 
  Input:
   filename  .tgf file name
  Ouput:
   V  # vertices by 3 list of vertex positions
   E  # edges by 2 list of edge indices
  
  Assumes that graph vertices are 3 dimensional


./mesh/readWRL.m
  readWRL - load a mesh from a VRML file
 
    [V, F] = readWRL(filename);
 
    Copyright (c) 2004 Gabriel Peyr


./mesh/regular_tetrahedral_mesh.m
  REGULAR_TETRAHEDRAL_MESH
 
  [T,V,F,N] = regular_tetrahedral_mesh(nx,ny,nz)
 
  Generates a regular tetrahedral mesh with dimensions (nx,ny,nz)
 
  Input:
    nx  number of points in x direction on grid
    ny  number of points in y direction on grid
    nz  number of points in z direction on grid
  Output:
    T  tetrahedra list of indices into V
    V  list of vertex coordinates in 3D
    F  triangle list of face indices into V
  %   N  sparse adjacency matrix, #vertices by #vertices
 
  Example
     [T,V,F] = regular_tetrahedral_mesh(3,3,3);
     tetramesh(T,V); %also try tetramesh(T,V,'FaceAlpha',0);
     trisurf(F,V(:,1),V(:,2),V(:,3));
  
  See also delaunayn, tetramesh
 


./mesh/rescaleOFF.m
  Takes an OFF file and rescales it so all vertex positions are between 0
  and 1 and writes it to a new file


./mesh/semiharmonic_embedding.m
  [S,V,D] = semiharmonic_embedding(V,F);
 
  Takes a mesh (V,F) and returns an embedding using the spectrum of the
  "semiharmonic operator". Then the semiharmonic distance between two points i
  and j can be computed as the euclidean distance between S(i,:) and S(j,:),
  namely: 
    dist_ij = sqrt(sum((S(i,:)-S(j,:)).^2,2));
  We also once referred to commute time embedding as "harmonic embedding"
  because "Biharmonic Distance" uses an embedding where the eigenvalues in
  the denominator are squared, hence that was the "biharmonic embedding",
  thus that could be the "harmonic embedding". Not to be confused with the
  embedding used in diffusion distance. Since here we take the square root of
  the eigenvalues, this could be called the "semiharmonic embeddding".
 
  This is a made up embedding with a made up name. Not much if anything is
  known about it.
  
  Input:
    V  vertex list
    F  face list
    dim requested dimension of the embedding
  Output:
    S  commute time embedding
    V  eigenvectors used in embedding
    D  eigenvalues used in embedding
  


./mesh/stacktimes.m
  STACKTIMES
  
  SV = stacktimes(S,V)
  
  Multiply each matrix in a vertical stack of matrices, S, times each
  vector in a list of row-vectors, V. Equivalent to the following:
 
  s = size(V,1);
  n = size(V,2);
  m = size(S,1)/s;
  SV = zeros(s,m);
  for ii = 0:(s-1)
   SV(ii+1,:) = (S((m*ii+1):(m*ii+m),:)*(V(ii+1,:)'))';
  end
 
 
  Inputs:
    S  a list of s, m by n matrices, stacked vertically. That is a s*m by n
      matrix
       OR
       a 3d-array, of size m by n by s
    V  a list of s n-size row-vectors, that is: an s by n array
  Outputs:
    SV = list of s m-size row-vectors
 


./mesh/stiffness_matrix.m


./mesh/tetgen.m
  TETGEN
  [V,T,F] = tetgen(SV,SF,IV)
 
  Call tetgen to construct a tetrahedral volume mesh with in a given triangle
  mesh with optional internal contrained vertices.
 
  Inputs:
    SV  list of surface vertex positions of exterior mesh, # vertices by 3
    SF  list of surface face indices of exterior triangle mesh, # faces by 3
    IV  list of internal vertex positions, # internal vertice by 3
    allow_resampling  allow resampling on the surface given [false]
  Outputs:
    V  list of tetrahedra vertices
    T  list of tetrahedra indices
    F  list of faces of 3D volume mesh
 


./mesh/tri2tet.m
  TRI2TET
 
  tri2tet(input_name,output_name,skeleton_name,samples_per_edge)
 
  Script to make 3d tet mesh from 2d triangle mesh with optional constraint
  to place tet vertices at skeleton vertices and samples along skeleton
  bones.
 
  Input:
   input_name  name of file contaning input vertices and faces of surface,
     should end in .off or .obj
   output_name  name of output file to be written with 3D tet mesh, should
     end in .mesh
   skeleton_name  optional name of .tgf containing skeleton vertices and
     edges
   samples_per_edge  optional sampling of "bones", edges of skeleton stored
     in skeleton_name
 


./mesh/tri2tgf.m
  TRI2TGF
 
  Script to convert a triangle mesh to a tgf graph (skeleton file)
 
  Inputs:
   input_name  name of file contaning input vertices and faces of surface,
     should end in .off or .obj
   output_name  name of output file to be written with 3D tet mesh, should
     end in .mesh


./mesh/tricontour.m
  tricontour
 
  tricontour(V,F,w,speedup)
 
  Plot a filled contour defined on top of a triangle mesh
  returns function handle
 
  Inputs:
   V  list of vertex positions
   F  list of face indices
   w  scalar values defined on V
   speedup optional speed up by not eliminating vertices outside shape {false}


./mesh/triharmonic_embedding.m
  [T,V,D] = triharmonic_embedding(V,F);
 
  Takes a mesh (V,F) and returns an embedding using the spectrum of the
  triharmonic operator. Then the triharmonic distance between two points i
  and j can be computed as the euclidean distance between T(i,:) and T(j,:),
  namely: 
    dist_ij = sqrt(sum((T(i,:)-T(j,:)).^2,2));
  We refer to this as "triharmonic embedding" because "Biharmonic
  Distance" uses an embedding where the eigenvalues in the denominator are
  squared, hence that was the "biharmonic embedding", thus this could be the
  "triharmonic embedding" since the eigenvalues are cubed.
  
  Input:
    V  vertex list
    F  face list
    dim requested dimension of the embedding
  Output:
    T  triharmonic embedding
    V  eigenvectors used in embedding
    D  eigenvalues used in embedding
  


./mesh/triinterp.m
  TRIINTERP
 
  [Xr,Yr,Wr] = triinterp()
 
  Given a scalar field S defined over a triangle mesh with vertices V and
  faces F, linearly interpolate the data for new positions U. NaNs are
  returned if position in U is not in or on a mesh triangle
 
  Inputs:
    V vertex position #V x 3 or #V x 2
    F list of faces #F x 3
    w scalar field defined over V, #V x 1
   speedup optional speed up by not eliminating vertices outside shape {false}
 
  Outputs:
    Xr  x values for griddata
    Yr  y values for griddata
    Wr  scalar values for griddata
 


./mesh/triinterp_fail.m
  TRIINTERP
 
  T = triinterp(V,F,S,U)
 
  Given a scalar field S defined over a triangle mesh with vertices V and
  faces F, linearly interpolate the data for new positions U. NaNs are
  returned if position in U is not in or on a mesh triangle
 
  Inputs:
    V vertex position #V x 3 or #V x 2
    F list of faces #F x 3
    S scalar field defined over V, #V x 1
    U vertex positions #U x 3 or #V x 2
  Outputs:
    T scalar field defined over U, #U x 1
 


./mesh/tsurf.m
  trisurf wrapper
  F: list of faces #F x 3
  V: vertex positiosn #V x 3 or #V x 2
  vertex_indices: show vertex indices on plot
                  0 -> off
                  1 -> text and grey background
                 >1 -> text
  face_indices: show face indices on plot
                  0 -> off
                  1 -> text and grey background
                 >1 -> text


./mesh/tt.m
  TT
 
  [Fp, Fi] = tt(F)
 
  Build a face adjacency data structure. From each face we can find where on
  its neighboring faces it's incident.
 
  Input:
    F  list of face indices, #faces by 3
  Output:
    Fp  #faces by 3, where Fp(i,j) tells the index of the neighboring triangle
      to the jth edge of the ith triangle in F. -1 if the jth edge of the ith
      triangle in F is a border edge. (jth edge refers to the edge opposite
      the jth vertex: so triangle in a triangle (a,b,c), the 1st edge is
      b-->c, the 2nd is c-->b and the 3rd is a-->b
    Fi  #faces by 3, where Fi(i,j) tells the position on the neighboring
      triangle to the jth edge of the ith triangle in F. -1 if the jth edge 
      if the ith triangle in F is a border edge. Uses the same indexing of
      positions of edges on a triangle as above.
 
  For example:
 
  F = [ 1 3 2;
        3 4 2];
  [Fp, Fi] = tt(F);
  Fp = 
      2    -1    -1
     -1     1    -1
  Fi = 
      2    -1    -1
     -1     1    -1
 


./mesh/udq2quattrans.m
  UDQ2QUATTRANS
 
  [Q,T] = udq2quattrans(UDQ)
 
  Convert a dual quaternion to rotation stored as a quaternion and a translation 
 
  Inputs:
   UDQ  list of rigid transformations for each rotation stored as dual
     quaternions
     2 by 4 #rotations
  Output:
   Q  list of rotations stored as quaternions, one for each rotation
     #rotations by 4 (1,i,j,k) 
   T  list of translations stored as vectors, one for each rotation
     #rotations by 3
 


./mesh/union2tet.m
  Script to take 3 meshes, a surface, a partial cage that intersects the
  surface and their volume-union's surface (probably from Blender), and use
  tetgen to generate a tet mesh that has tets in the volume-union with faces
  of the original surface .
 
  Inputs:
    surface_name  file containing original surface
    cage_name  file containing (partial) cage
    union_name  file containing union surface
  Output:
    tet_name  file to be written with .mesh tet mesh


./mesh/upsample.m
  UPSAMPLE
 
  Upsample a mesh by adding vertices on existing edges/faces
 
  Inputs:
   V  #vertices by 3 list of vertex positions
   F  #faces by 3 list of face indices
  Outpus:
   VV new vertex positions
   FF new list of face indices
 
  This is loop subdivision without moving the points
 


./mesh/vtxpolyfit.m
  [polycoefs] = vtxpolyfit(mmesh,vtxset,vals,deg), produces #V x m matrix of
  polynomial coefficients, m = (deg+1)*(deg+2)/2
  the ordering of monomials is 1, u, v, u^2, uv v^2, u^3, u^2 v ..
  mmesh: data structure produced by hds
  vtxset: a set of indices
  vals: values at vertices
  deg: polynomial total degree 
       primarily intended for deg = 1,2
  the fit is regularized, so that if there are not enough degrees of
  freedom a reasonable result should still be produced
  if 2 layers of vertices are fixed, there is enough dofs for deg 1
  and typically not enough for deg 2
  if 3 layers are fixed then there is typically enough dofs for deg 2


./mesh/writeBDLChunkHeader.m
  writes chunk header into file stream
 
  Usage:
    headerStart = writeChunkHeader( fp, chunktype, nBytes )


./mesh/writeBDLMeshChunk.m
  write a mesh chunk to a file stream that can be processed by the external
  viewer.
 
  Usage:
     writeMeshChunk( fp, mesh )
 
  mesh fields: 
  V  (required)  vertices
  F              faces
  col            colors
  baseColor      a single color for the whole mesh
  UV             uv coords


./mesh/writeMESH.m
  WRITEMESH writes an MESH file with vertex/face/tet information
 
  writeMESH(filename,V,T,F)
 
 
  Input:
   filename  path to .mesh file
   V  #V by 3 list of vertices
   T  #T by 4 list of tet indices
   F  #F by 3 list of triangle indices
 
  See also readMESH
 


./mesh/writeNODE.m
  WRITENODE
  writeNODE(filename,V)
 
  Write vertex positions to a .node file
 
  Inputs:
   filename  name of output file
   V  list of vertex positions


./mesh/writeOBJ.m
  WRITEOBJ writes an OBJ file with vertex/face information
 
  writeOBJ(filename,V,F,UV,N)
 
  Input:
   filename  path to .obj file
  Outputs:
   V  #V by 3 list of vertices
   F  #F by 3 list of triangle indices
   UV  #V by 2 list of texture coordinates
   N  #V by 3 list of normals
 


./mesh/writeOFF.m
  WRITEOFF writes an OFF file with vertex/face information
 
  writeOFF(filename
 
  Input:
   filename  path to .obj file
   V  #V by 3 list of vertices
   F  #F by 3 list of triangle indices
   UV  #V by 2 list of texture coordinates
   C  #V by 3 list of colors
   N  #V by 3 list of normals


./mesh/writeTGF.m
  WRITETGF
 
  writeTGF(filename,V,E)
 
  Write a graph to a .tgf file
 
  Input:
   filename  .tgf file name
   V  # vertices by 3 list of vertex positions
   E  # edges by 2 list of edge indices
  
  Assumes that graph vertices are 3 dimensional


./old/curve_editing_1d.m
  Creates and solves system of equations to determine new positions of
  points on a curve given target fixed positions
 
  INPUT
  fixed       dict of fixed positions (index, value)
  undeformed  original input positions
  h           distance between elements
 
  OUTPUT
  deformed    new positions given target fixed postions


./old/curve_editing_1d_system.m
  Constructs the system matrix and right-hand side for minimizing the
  enrgy function:
  F (y) = (1/2)\int{y"(t)}{dt}
  which is to say it solves
  y???? = 0
 
  The approximation for the fourth derivative used is:
  (fj-2 - 4*fj-1 + 6*fj - 4*fj+1 + fj+2)/(h^4)
 
  NOTE: the returned system is missing boundary and fixed point
  conditions
 
  INPUT
  undeformed  original input positions
  h           distance between elements
 
  OUTPUT
  A           system matrix
  rhs         right-hand side


./old/curve_editing_1d_system_fixed.m
  Constructs the system matrix and right-hand side, whose solution is the
  new positions of points on a curve given fixed target positions
 
  INPUT
  fixed       dict of fixed positions (index, value)
  undeformed  original input positions
  h           distance between elements
 
  OUTPUT
  A           system matrix
  rhs         right-hand side


./paths/depends.m
  DEPENDS
 
  C = depends('fun')
 
  Inputs:
   'fun'  string, name of function or path to function
   depth  number of levels to explore
  Outputs:
   C  cell array of paths to dependencies
 
  Example:
   % Get dependencies and zip into a file
   C = depends('myfun');
   zip('myfun.zip',C);
 
   % Get dependencies and extract just file base names and print
   C = depends('myfun');
   N = regexprep(C,'^.*\/','')
   fprintf('myfun depends on:\n');
   fprintf('  %s\n',N{:})
 
   % Get dependencies and remove mosek paths
   C = depends('myfun');
   C = C(cellfun(@isempty,strfind(C,'opt/local/mosek')));
  


./plot/interactive_fit.m
  function interactive_fit(filename,x_name,y_name,skip_interaction)
  Reads in plot X and Y data from filename stored in variables x_name, and
  y_name respectively. Then interactively lets the user pick axes, slope and
  y_intercept to match the data. Those variables are then saved in the file.
  load the data from the .mat file


./plot/interactive_fit_plot.m


./plot/myaa.m
 MYAA Render figure with anti-aliasing.
    MYAA
    Anti-aliased rendering of the current figure. This makes graphics look 
    a lot better than in a standard matlab figure, which is useful for  
    publishing results on the web or to better see the fine details in a
    complex and cluttered plot. Some simple keyboard commands allow
    the user to set the rendering quality interactively, zoom in/out and
    re-render when needed.
 
    Usage:
      myaa: Renders an anti-aliased version of the current figure.
 
      myaa(K): Sets the supersampling factor to K. Using a 
      higher K yields better rendering but takes longer time. If K is 
      omitted, it defaults to 4. It may be useful to run e.g. myaa(2) to 
      make a low-quality rendering as a first try, because it is a lot 
      faster than the default.
 
      myaa([K D]): Sets supersampling factor to K but downsamples the 
      image by a factor of D. If D is larger than K, the rendered image
      will be smaller than the original. If D is smaller than K, the 
      rendering will be bigger.
 
      myaa('publish'): An experimental parameter, useful for publishing 
      matlab programs (see example 3). Beware, it kills the current figure.
 
    Interactivity:
      The anti-aliased figure can be updated with the following keyboard 
      commands:
 
      <space>       Re-render image (to reflect changes in the figure)
      +             Zoom in (decrease downsampling factor)
      -             Zoom out (increase downsampling factor)
      1 ... 9       Change supersampling and downsampling factor to ...
      q             Quit, i.e. close the anti-aliased figure
 
    Myaa can also be called with up to 3 parameters.
    FIG = MYAA(K,AAMETHOD,FIGMODE)
    Parameters and output:
      K         Subsampling factor. If a vector is specified, [K D], then 
                the second element will describe the downsampling factor. 
                Default is K = 4 and D = 4.
      AAMETHOD  Downsampling method. Normally this is chosen automatically.
                'standard': convolution based filtering and downsampling
                'imresize': downsampling using the imresize command from
                the image toolbox.
                'noshrink': used internally
      FIGMODE   Display mode
                'figure': the normal mode, a new figure is created
                'update': internally used for interactive sessions
                'publish': used internally
      FIG       A handle to the new anti-aliased figure
 
    Example 1:
      spharm2;
      myaa;
      % Press '1', '2' or '4' and try '+' and '-'
      % Press 'r' or <space> to update the anti-aliased rendering, e.g. 
      % after rotating the 3-D object in the original figure.
 
    Example 2:
      line(randn(2500,2)',randn(2500,2)','color','black','linewidth',0.01)
      myaa(8);
 
    Example 3:
      xpklein;
      myaa(2,'standard');
 
    Example 3:
      Put the following in test.m
         %% My test publish
         %  Testing to publish some anti-aliased images
         %
         spharm2;          % Produce some nice graphics
         myaa('publish');  % Render an anti-aliased version
 
      Then run:
         publish test.m;
         showdemo test;
 
 
    BUGS:
      Dotted and dashed lines in plots are not rendered correctly. This is
      probably due to a bug in Matlab and it will hopefully be fixed in a
      future version.
      The OpenGL renderer does not always manage to render an image large
      enough. Try the zbuffer renderer if you have problems or decrease the
      K factor. You can set the current renderer to zbuffer by running e.g. 
      set(gcf,'renderer','zbuffer').
 
    See also PUBLISH, PRINT
 
    Version 1.1, 2008-08-21
    Version 1.0, 2008-08-05
 
    Author: Anders Brun
            anders@cb.uu.se
 


./plot/vectarrow.m
    P: list of points #x3
    V: list of vectors #x3
    Rentian Xiong 4-18-05


./utility/progressbar.m
  PROGRESSBAR - display a progress bar
 
  progressbar(n,N,w);
 
  Deletes the current line and displays the progress of n out of N.
  Inputs:
    n partial amount, should start at 1.
    N total amount
    w is the width of the bar (default w=20).
 
  TODO: should start at 0
 




(This document autogenerated on 27-Mar-2011)
