function C = cotangent(V,F)
  % COTANGENT compute the cotangents of each angle in mesh (V,F)
  % 
  % C = cotangent(V,F)
  %
  % Inputs:
  %   V  #V by dim list of rest domain positions
  %   F  #F by {3|4} list of {triangle|tetrahedra} indices into V
  % Outputs:
  %   C  #F by {3|6} list of cotangents corresponding angles
  %     for triangles, columns correspond to edges 23,31,12
  %     for tets, columns correspond to edges 23,31,12,41,42,43
  %
  % See also: cotmatrix
  %
  % Copyright 2012, Alec Jacobson (jacobson@inf.ethz.ch)

  switch size(F,2)
  case 3
    % triangles
    % edge lengths numbered same as opposite vertices
    l = [ ...
      sqrt(sum((V(F(:,2),:)-V(F(:,3),:)).^2,2)) ...
      sqrt(sum((V(F(:,3),:)-V(F(:,1),:)).^2,2)) ...
      sqrt(sum((V(F(:,1),:)-V(F(:,2),:)).^2,2)) ...
      ];
    i1 = F(:,1); i2 = F(:,2); i3 = F(:,3);
    l1 = l(:,1); l2 = l(:,2); l3 = l(:,3);
    % semiperimeters
    s = (l1 + l2 + l3)*0.5;
    % Heron's formula for area
    dblA = 2*sqrt( s.*(s-l1).*(s-l2).*(s-l3));
    % cotangents and diagonal entries for element matrices
    % correctly divided by 4 (alec 2010)
    C = [ ...
      (l2.^2 + l3.^2 -l1.^2)./dblA/4 ...
      (l1.^2 + l3.^2 -l2.^2)./dblA/4 ...
      (l1.^2 + l2.^2 -l3.^2)./dblA/4 ...
      ];

  case 4
    % tetrahedra
    T = F;
    % number of tetrahedra
    m = size(T,1);

    if(size(T,1) == 4 && size(T,2) ~=4)
      warning('T seems to be 4 by #T, it should be #T by 4');
    end
    T = T';

    % Jacobian 
    % size(T,2) stacked jacobians (one per tetrahedron)
    J = [ ...
      V(T(1,:),1) - V(T(4,:),1), ...
        V(T(2,:),1) - V(T(4,:),1), ...
        V(T(3,:),1) - V(T(4,:),1), ...
      V(T(1,:),2) - V(T(4,:),2), ...
        V(T(2,:),2) - V(T(4,:),2), ...
        V(T(3,:),2) - V(T(4,:),2), ...
      V(T(1,:),3) - V(T(4,:),3), ...
        V(T(2,:),3) - V(T(4,:),3), ...
        V(T(3,:),3) - V(T(4,:),3), ...
      ];
    i = [ 
      (3*((1:m)-1)+1)', ...
      (3*((1:m)-1)+1)', ...
      (3*((1:m)-1)+1)', ...
      (3*((1:m)-1)+2)', ...
      (3*((1:m)-1)+2)', ...
      (3*((1:m)-1)+2)', ...
      (3*((1:m)-1)+3)', ...
      (3*((1:m)-1)+3)', ...
      (3*((1:m)-1)+3)', ...
      ];
    j = [ 
      (3*((1:m)-1)+1)', ...
      (3*((1:m)-1)+2)', ...
      (3*((1:m)-1)+3)', ...
      (3*((1:m)-1)+1)', ...
      (3*((1:m)-1)+2)', ...
      (3*((1:m)-1)+3)', ...
      (3*((1:m)-1)+1)', ...
      (3*((1:m)-1)+2)', ...
      (3*((1:m)-1)+3)', ...
      ];
    % sparse jacobian blocks along diagonal
    Jsp = sparse(i,j,J);

    % stacked right hand side
    rhs = [1,0,0,-1;0,1,0,-1;0,0,1,-1];
    rhs = repmat(rhs,m,1);

    % stacked E matrices
    E = Jsp'\rhs;
    detJ = ...
      J(:,1).*J(:,5).*J(:,9) + ...
      J(:,2).*J(:,6).*J(:,7) + ...
      J(:,3).*J(:,4).*J(:,8) - ...
      J(:,1).*J(:,6).*J(:,8) - ...
      J(:,2).*J(:,4).*J(:,9) - ...
      J(:,3).*J(:,5).*J(:,7);

    i = [(1:size(E,1))', (1:size(E,1))', (1:size(E,1))', (1:size(E,1))'];
    j = floor((i-1)./3)*4 + [ones(size(E,1),1), 2*ones(size(E,1),1), 3*ones(size(E,1),1), 4*ones(size(E,1),1)];
    % stacked E' * E matrices
    ETE = sparse(i,j,E)'*E;

    detJ = repmat(reshape(repmat(detJ',4,1),size(ETE,1),1),1,4);
    % Stacked K matrices
    K = detJ.*ETE./6;

    Kdiags = K([1:4:4*m 4*m+(2:4:4*m) 4*2*m+(3:4:4*m) 4*3*m+(4:4:4*m)]);
    % flip sign to match cotmatix.m
    if all(Kdiags)>0
      warning('Flipping sign of cotangent, so that cots are positive');
      K = -K;
    end

    % at this point every 4x4 block in K should be symmetric

    % K((i-1)*4 + a,b) contains cotangent for edge F(i,a) to F(i,b)
    C = [ ...
      K(2:4:4*m,3) ...
      K(3:4:4*m,1) ...
      K(1:4:4*m,2) ...
      K(4:4:4*m,1) ...
      K(4:4:4*m,2) ...
      K(4:4:4*m,3) ...
      ];
  otherwise
    error('Unsupported simplex type');
  end

end
