function [G,Gx,Gy,Gz] = fd_grad(side)
  % FD_GRAD build a finite difference gradient for a 3D grid.
  %
  % This is a weird finite difference gradient. G'*G produces the 45° rotated
  % Laplacian rather than the usual axis aligned one
  %
  % G = fd_grad(side)
  % 
  % Inputs:
  %   side  containing number of vertices on each side of grid [x y z]
  % Outputs:
  %   G   numel(side)*prod(side-1) by prod(side)  gradient matrix
  %

  function B = vec(A)
    B = A(:)';
  end

  %I = sub2ind(side([2 1 3]),1:prod(side))';
  %I = reshape(I,side);
  %L = sparse( ...
  %  [vec(I(2:end  ,:,:)) vec(I(:,2:end  ,:)) vec(I(:,:,2:end  ))], ...
  %  [vec(I(1:end-1,:,:)) vec(I(:,1:end-1,:)) vec(I(:,:,1:end-1))], ...
  %  1,prod(side),prod(side));
  %L = L + L';
  %L = L-diag(sum(L,2));


  m = prod(side-1);
  n = prod(side);
  yxz = [side(2) side(1) side(3:end)];
  I = sub2ind(yxz,1:n)';
  I = reshape(I,yxz);
  J = sub2ind(yxz-1,1:m)';
  J = reshape(J,yxz-1);

  switch numel(side)
  case 3
    Gx = ...
      sparse( ...
        [vec(J) vec(J) vec(J) vec(J)], ...
        [vec(I(1:end-1,1:end-1,1:end-1)) vec(I(2:end  ,1:end-1,1:end-1)) ... 
         vec(I(1:end-1,1:end-1,2:end  )) vec(I(2:end  ,1:end-1,2:end  ))], ...
        -1,m,n) + ...
      sparse( ...
        [vec(J) vec(J) vec(J) vec(J)], ...
        [vec(I(1:end-1,2:end  ,1:end-1)) vec(I(2:end  ,2:end  ,1:end-1)) ... 
         vec(I(1:end-1,2:end  ,2:end  )) vec(I(2:end  ,2:end  ,2:end  ))], ...
         1,m,n);
    Gy = ...
      sparse( ...
        [vec(J) vec(J) vec(J) vec(J)], ...
        [vec(I(1:end-1,1:end-1,1:end-1)) vec(I(1:end-1,1:end-1,2:end  )) ... 
         vec(I(1:end-1,2:end  ,1:end-1)) vec(I(1:end-1,2:end  ,2:end  ))], ...
        -1,m,n) + ...
      sparse( ...
        [vec(J) vec(J) vec(J) vec(J)], ...
        [vec(I(2:end  ,1:end-1,1:end-1)) vec(I(2:end  ,1:end-1,2:end  )) ... 
         vec(I(2:end  ,2:end  ,1:end-1)) vec(I(2:end  ,2:end  ,2:end  ))], ...
         1,m,n);
    Gz = ...
      sparse( ...
        [vec(J) vec(J) vec(J) vec(J)], ...
        [vec(I(1:end-1,1:end-1,1:end-1)) vec(I(1:end-1,2:end  ,1:end-1)) ... 
         vec(I(2:end  ,1:end-1,1:end-1)) vec(I(2:end  ,2:end  ,1:end-1))], ...
        -1,m,n) + ...
      sparse( ...
        [vec(J) vec(J) vec(J) vec(J)], ...
        [vec(I(1:end-1,1:end-1,2:end  )) vec(I(1:end-1,2:end  ,2:end  )) ... 
         vec(I(2:end  ,1:end-1,2:end  )) vec(I(2:end  ,2:end  ,2:end  ))], ...
         1,m,n);
      G = [Gx;Gy;Gz];
  case 2
    %[X,Y] = meshgrid(1:side(1),1:side(2));
    %[Q,V] = surf2patch(X,Y);
    %V = V(:,1:2);
    %tsurf(Q,V,'VertexIndices',1,'FaceIndices',1);
    %axis equal;

    Gx = ...
      sparse( ...
        [vec(J) vec(J)], ...
        [vec(I(1:end-1,1:end-1)) vec(I(2:end,1:end-1))], ...
        -1,m,n) + ...
      sparse( ...
        [vec(J) vec(J)], ...
        [vec(I(1:end-1,2:end))  vec(I(2:end,2:end))], ...
        1,m,n);
    Gy = ...
      sparse( ...
        [vec(J) vec(J)], ...
        [vec(I(1:end-1,1:end-1)) vec(I(1:end-1,2:end))], ...
        -1,m,n) + ...
      sparse( ...
        [vec(J) vec(J)], ...
        [vec(I(2:end,1:end-1))  vec(I(2:end,2:end))], ...
        1,m,n);
    G = [Gx;Gy];
    % Squaring produces the **45° rotated** Laplacian, not the usual axis
    % aligned one.
    % L = 0.5*(G'*G);
  end

end
